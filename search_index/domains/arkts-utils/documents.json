[
  {
    "doc_id": "Readme-CN",
    "title": "ArkTS（方舟编程语言）",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\Readme-CN.md",
    "summary": "- [ArkTS简介](arkts-overview.md) - ArkTS基础类库 - [ArkTS基础类库概述](arkts-utils-overview.md) - XML生成、解析与转换 - [XML概述](xml-overview.md) - [XML生成](xml-generation.md) - [XML解析](xml-parsing.md) - [XML转换](xml-conversion.md) - [Buffer与FastBuffer](buffer.md) - [JSON扩展库](arkts-json.md) - ArkTS容器类库 - [容器类库概述](containe",
    "key_topics": [
      "ArkTS（方舟编程语言）",
      "- [ArkTS简介](arkts-overview.md)"
    ],
    "sections": []
  },
  {
    "doc_id": "arkoptions-guide",
    "title": "在build-profile.json5中配置arkOptions",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkoptions-guide.md",
    "summary": "arkOptions主要提供ArkTS编译相关配置，当前文档介绍arkOptions中types配置类型、maxFlowDepth配置控制流分析最大栈深度等，arkOptions中的其他配置项请参考[build-profile.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-configuration-file-overview)。",
    "key_topics": [
      "在build-profile.json5中配置arkOptions",
      "概述",
      "types",
      "types配置文件标签说明",
      "arkOptions中的types字段配置说明"
    ],
    "sections": [
      "概述",
      "types",
      "types配置文件标签说明",
      "arkOptions中的types字段配置说明",
      "注意事项",
      "maxFlowDepth",
      "maxFlowDepth配置文件标签说明",
      "arkOptions下的tscConfig中maxFlowDepth字段配置说明",
      "注意事项",
      "transformLib",
      "transformLib配置文件标签说明",
      "arkOptions中的transformLib字段配置说明",
      "注意事项"
    ]
  },
  {
    "doc_id": "arkts-async-lock-introduction",
    "title": "异步锁",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-async-lock-introduction.md",
    "summary": "为了解决多线程并发实例间的数据竞争问题，ArkTS引入了异步锁能力。异步锁可能会被类对象持有，因此为了更方便地在并发实例间获取同一个异步锁对象，[AsyncLock对象](../reference/apis-arkts/arkts-apis-arkts-utils-locks.md#asynclock)支持跨线程引用传递。 由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）。同时，异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题。",
    "key_topics": [
      "异步锁",
      "使用示例",
      "为了解决多线程并发实例间的数据竞争问题，ArkTS引入了异步锁能力"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "arkts-bytecode-file-format",
    "title": "方舟字节码文件格式",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-bytecode-file-format.md",
    "summary": "本文详细介绍了方舟字节码文件的格式，旨在帮助开发者深入理解字节码文件的组成结构，以指导字节码的分析和修改。 本文内容基于方舟字节码版本号12.0.6.0（版本号为方舟编译器内部保留字段，开发者无需关注，仅供准确对照之用）。 方舟字节码使用了多种基础和复合数据类型，以下为常见类型的定义和说明。",
    "key_topics": [
      "方舟字节码文件格式",
      "约束",
      "字节码文件数据类型",
      "整型",
      "字符串"
    ],
    "sections": [
      "约束",
      "字节码文件数据类型",
      "整型",
      "字符串",
      "TaggedValue",
      "TypeDescriptor",
      "字节码文件布局",
      "Header",
      "Version",
      "ForeignClass",
      "ForeignMethod",
      "ClassIndex",
      "Class",
      "ClassAccessFlag",
      "ClassTag",
      "Field",
      "FieldTag",
      "Method",
      "MethodIndexData",
      "MethodTag",
      "Code",
      "TryBlock",
      "CatchBlock",
      "Annotation",
      "AnnotationElementTag",
      "AnnotationElement",
      "Value formats",
      "LineNumberProgramIndex",
      "DebugInfo",
      "IndexSection",
      "IndexHeader",
      "ClassRegionIndex",
      "Type",
      "MethodStringLiteralRegionIndex",
      "LiteralArray",
      "Literal"
    ]
  },
  {
    "doc_id": "arkts-bytecode-function-name",
    "title": "方舟字节码函数命名规则",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-bytecode-function-name.md",
    "summary": "本文介绍字节码文件中[Method](arkts-bytecode-file-format.md#method)的`name_off`字段指向的字符串的命名规则，该命名规则从方舟字节码文件版本`12.0.4.0`开始生效。 模块加载时被执行的函数，名称固定为`func_main_0`。 其他函数在字节码文件中的名称结构如下： ```ts ``` 下面的章节将会详细介绍前缀和原函数名。",
    "key_topics": [
      "方舟字节码函数命名规则",
      "概述",
      "入口函数",
      "非入口函数",
      "前缀"
    ],
    "sections": [
      "概述",
      "入口函数",
      "非入口函数",
      "前缀",
      "原函数名",
      "示例"
    ]
  },
  {
    "doc_id": "arkts-bytecode-fundamentals",
    "title": "方舟字节码基本原理",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-bytecode-fundamentals.md",
    "summary": "方舟字节码（Ark Bytecode）是由方舟编译器编译ArkTS/TS/JS生成的，提供给方舟运行时解释执行的二进制文件。方舟字节码中的主要内容是方舟字节码指令。<br> 本文旨在介绍方舟字节码指令相关的设计，将在后续章节中对构成指令的重要概念和具体的指令格式及含义进行说明，帮助开发者了解方舟字节码指令，指导开发者进行指令相关的特性开发工作。<br> 一条方舟字节码指令，由操作码（指令的名称）和指令入参列表组成。操作码包含无前缀的操作码和有前缀的操作码两种。寄存器、立即数以及string id/method id/literal id均可以作为指令的入参。",
    "key_topics": [
      "方舟字节码基本原理",
      "总体设计",
      "概述",
      "术语和约束",
      "字节码构成"
    ],
    "sections": [
      "总体设计",
      "概述",
      "术语和约束",
      "字节码构成",
      "值存储方式",
      "函数调用规范",
      "字节码格式说明",
      "字节码汇总集合"
    ]
  },
  {
    "doc_id": "arkts-bytecode-overview",
    "title": "方舟字节码概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-bytecode-overview.md",
    "summary": "方舟字节码文件是ArkTS/TS/JS源码编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。 - 方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和映射关系。 - 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。",
    "key_topics": [
      "方舟字节码概述",
      "方舟字节码文件是ArkTS/TS/JS源码编译后的二进制产物"
    ],
    "sections": []
  },
  {
    "doc_id": "arkts-collections-introduction",
    "title": "共享容器",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-collections-introduction.md",
    "summary": "ArkTS共享容器（[@arkts.collections (ArkTS容器集)](../reference/apis-arkts/arkts-apis-arkts-collections.md)）是一种在并发实例间共享传输的容器类，用于并发场景下的高性能数据传递。它的功能与ECMAScript 262规范定义的容器类似，但存在部分差异，具体可见[共享容器与原生API方法的行为差异对比](#共享容器与原生api方法的行为差异对比)。 ArkTS共享容器在多个并发实例间传递时，默认采用引用传递，允许多个并发实例操作同一容器实例。此外，还支持拷贝传递，即每个并发实例拥有独立的ArkTS容器实例。",
    "key_topics": [
      "共享容器",
      "ArkTS容器集",
      "共享容器与原生API方法的行为差异对比",
      "Array",
      "ArrayBuffer"
    ],
    "sections": [
      "ArkTS容器集",
      "共享容器与原生API方法的行为差异对比",
      "Array",
      "ArrayBuffer",
      "TypedArray（以Int8Array为例）",
      "Map",
      "Set"
    ]
  },
  {
    "doc_id": "arkts-condition-variable-introduction",
    "title": "异步等待",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-condition-variable-introduction.md",
    "summary": "ArkTS引入了异步任务的等待和被唤醒能力，以解决多线程任务时序控制问题。异步任务的等待和被唤醒[ConditionVariable](../reference/apis-arkts/arkts-apis-arkts-utils-locks.md#conditionvariable18)对象支持跨线程引用传递。 ArkTS语言支持异步操作，现已增加异步任务的等待和唤醒功能。当异步任务收到唤醒通知或等待超时后，将继续执行。 > **说明：** > > 使用异步方法需标记为async，调用时需用await修饰，确保时序正确。",
    "key_topics": [
      "异步等待",
      "使用示例",
      "ArkTS引入了异步任务的等待和被唤醒能力，以解决多线程任务时序控制问题"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "arkts-cross-language-interaction",
    "title": "ArkTS跨语言交互",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-cross-language-interaction.md",
    "summary": "除了支持使用ArkTS开发外，开发者还可以通过Node-API实现ArkTS与C/C++(Native)的跨语言交互能力。 OpenHarmony的Node-API是基于Node.js社区版本的扩展实现，但与原生Node-API并不完全兼容。",
    "key_topics": [
      "ArkTS跨语言交互",
      "除了支持使用ArkTS开发外，开发者还可以通过Node-API实现ArkTS与C/C++(Native)的跨语言交互能力"
    ],
    "sections": []
  },
  {
    "doc_id": "arkts-dynamic-import",
    "title": "动态加载",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-dynamic-import.md",
    "summary": "动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块之间可通过变量动态import来访问彼此导出的内容，可避免编译期强依赖，实现模块解耦。 应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态import代替[静态import](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态import的场景： * 当静态import的模块明显降低了代码的加载速度且很少被使用，或者并不需要马上使用它。",
    "key_topics": [
      "动态加载",
      "技术适用场景介绍",
      "业务扩展场景介绍",
      "动态import实现方案介绍",
      "动态import实现中的关键点"
    ],
    "sections": [
      "技术适用场景介绍",
      "业务扩展场景介绍",
      "动态import实现方案介绍",
      "动态import实现中的关键点",
      "动态import常量表达式",
      "动态import变量表达式",
      "HAR模块间动态import依赖解耦"
    ]
  },
  {
    "doc_id": "arkts-import-native-module",
    "title": "静态方式加载Native模块",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-import-native-module.md",
    "summary": "在ES6(ECMAScript 6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义的语法规则。为支持开发者使用该功能导入Native模块（so）导出的内容，ArkTS进行了相关适配，并提供了以下几种支持写法。 在Native模块的index.d.ts文件中导出，并在文件内直接导入。 ``` TypeScript // libentry.so对应的index.d.ts export const add: (a: number, b: number) => number; ```",
    "key_topics": [
      "静态方式加载Native模块",
      "直接导入",
      "具名导入",
      "默认导入",
      "命名空间导入"
    ],
    "sections": [
      "直接导入",
      "具名导入",
      "默认导入",
      "命名空间导入",
      "间接导入",
      "转为具名变量导出再导入",
      "转为命名空间导出再导入",
      "动态导入",
      "直接导入",
      "间接导入"
    ]
  },
  {
    "doc_id": "arkts-json",
    "title": "JSON扩展库",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-json.md",
    "summary": "该库扩展了原生JSON功能，提供了额外的错误处理、循环引用检测、BigInt处理以及对不同输入类型的严格检查。代码中底层依赖于原生JSON.parse和JSON.stringify，但在此基础上加入了多种自定义逻辑并提供额外的has和remove接口，具体可见[@arkts.json](../reference/apis-arkts/js-apis-json.md)。 JSON扩展库主要适用于以下场景： - 需要处理BigInt的JSON解析或序列化。",
    "key_topics": [
      "JSON扩展库",
      "场景介绍",
      "JSON扩展说明",
      "parse",
      "stringify"
    ],
    "sections": [
      "场景介绍",
      "JSON扩展说明",
      "parse",
      "stringify",
      "has",
      "remove",
      "总结",
      "开发场景",
      "解析包含嵌套引号的JSON字符串场景",
      "解析包含大整数的JSON字符串场景",
      "序列化BigInt对象场景",
      "序列化浮点数number场景"
    ]
  },
  {
    "doc_id": "arkts-lazy-import",
    "title": "延迟加载（lazy import）",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-lazy-import.md",
    "summary": "随着应用程序功能的扩展，冷启动时间显著增加，主要是因为启动初期加载了大量未实际执行的模块。这不仅延长了应用的初始化时间，还浪费了资源。需要精简加载流程，剔除非必需的文件执行，优化冷启动性能，确保用户体验流畅。 > **说明：** > > - 延迟加载特性在API 12版本开始支持。 > > - 开发者如需在API 12上使用lazy import语法，需在工程中配置\"compatibleSdkVersionStage\": \"beta3\"，否则将无法通过编译。",
    "key_topics": [
      "延迟加载（lazy import）",
      "功能特性",
      "使用方式",
      "场景行为解析",
      "lazy-import与动态加载的区别"
    ],
    "sections": [
      "功能特性",
      "使用方式",
      "场景行为解析",
      "lazy-import与动态加载的区别",
      "语法规格及起始支持版本",
      "错误示例",
      "不推荐用法",
      "注意事项",
      "可延迟加载文件检测",
      "检测步骤",
      "生成文件介绍",
      "检测原理",
      "加载情况总结",
      "被使用文件",
      "未被使用文件",
      "使用示例"
    ]
  },
  {
    "doc_id": "arkts-module-side-effects",
    "title": "模块加载副作用及优化",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-module-side-effects.md",
    "summary": "当使用[ArkTS模块化](module-principle.md)时，模块的加载和执行可能会引发**副作用**。副作用是指在模块导入时除了导出功能或对象之外，额外的行为或状态变化，**这些行为可能影响程序的其他部分，并导致产生非预期的顶层代码执行、全局状态变化、原型链修改、导入内容未定义等问题**。 **副作用产生场景** 模块在被导入时，整个模块文件中的顶层代码会立即执行，而不仅仅是导出的部分。这意味着，即使只想使用模块中的某些导出内容，任何在顶层作用域中执行的代码也会运行，从而产生副作用。",
    "key_topics": [
      "模块加载副作用及优化",
      "概述",
      "ArkTS模块化导致副作用的场景及优化方式",
      "模块执行顶层代码",
      "修改全局对象"
    ],
    "sections": [
      "概述",
      "ArkTS模块化导致副作用的场景及优化方式",
      "模块执行顶层代码",
      "修改全局对象",
      "修改应用级ArkUI组件的状态变量信息",
      "修改内置全局变量或原型链（ArkTS内禁止修改对象原型与内置方法）",
      "循环依赖",
      "延迟加载（lazy import）改变模块执行顺序，可能导致预期的全局变量未定义",
      "通过import路径展开优化性能",
      "原理",
      "副作用"
    ]
  },
  {
    "doc_id": "arkts-overview",
    "title": "ArkTS简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-overview.md",
    "summary": "ArkTS是OpenHarmony应用开发的官方高级语言。 ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。",
    "key_topics": [
      "ArkTS简介",
      "ArkTS是OpenHarmony应用开发的官方高级语言"
    ],
    "sections": []
  },
  {
    "doc_id": "arkts-runtime-faq",
    "title": "ArkTS运行时常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-runtime-faq.md",
    "summary": "如果使用正则运算时结果与期望不符，请检查以下场景。 ``` TypeScript let str = '\\u2642'; let res = str.replace(/\\b/g, '/'); console.info('res = ' + res); // 期望输出: res = ♂。 // 实际输出: res = /♂/。 ``` 规避方案：暂无。",
    "key_topics": [
      "ArkTS运行时常见问题",
      "正则运算与预期输出结果不一致场景",
      "正则运算对于\\b处理与预期不一致",
      "正则运算对于大小写的处理与预期不一致",
      "正则运算/()/ug匹配时lastIndex与预期不一致"
    ],
    "sections": [
      "正则运算与预期输出结果不一致场景",
      "正则运算对于\\b处理与预期不一致",
      "正则运算对于先行断言((?=pattern)或(?!pattern)) 嵌套在后行断言((?<=pattern)或(?<!pattern))内部的场景与预期不一致",
      "正则运算对于大小写的处理与预期不一致",
      "正则运算/()/ug匹配时lastIndex与预期不一致",
      "正则运算[]内部使用'-'与预期不一致",
      "正则运算具名捕获组获取与预期不一致",
      "正则匹配使用'|'与预期不一致",
      "TypedArray.prototype.map触发内联缓存优化后，在回调中将数值number转为浮点数number与期望不一致",
      "Number.parseFloat解析浮点数number类型非规格化数值与期望不一致",
      "Set constructor入参为多维数组的解析与期望不一致",
      "Object.entries处理Uint8Array与Uint16Array数组结果与期望不一致",
      "字符串 `replace` 接口对于第一个参数为空字符串的场景与预期不一致",
      "Async函数内部异常的处理机制",
      "Array.flatMap()接口常见问题",
      "ArkTS使用场景",
      "ArkUI使用场景",
      "Array.flatMap规避方案",
      "Proxy的handler对象中key类型与EcmaScript规范定义不一致",
      "JSON.stringify的replacer函数中数组索引的key类型与EcmaScript规范定义不一致"
    ]
  },
  {
    "doc_id": "arkts-runtime-overview",
    "title": "ArkTS运行时概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-runtime-overview.md",
    "summary": "ArkTS运行时是OpenHarmony上应用的默认语言运行时，支持ArkTS、TS和JS语言的字节码及相关标准库。它提供解释器、AOT和JIT高效执行方式，并通过[Node-API](../napi/napi-introduction.md)实现完善的跨语言调用接口，支持多语言混合开发。 ArkTS Runtime主要由四个子系统组成： - **Core Subsystem**：主要由与语言无关的基础运行库组成，其中包括承载字节码的File组件、支持Debugger的Tooling组件以及负责适配系统调用的Base库组件等。",
    "key_topics": [
      "ArkTS运行时概述",
      "ArkTS运行时是OpenHarmony上应用的默认语言运行时，支持ArkTS、TS和JS语言的字节码及相关标准库"
    ],
    "sections": []
  },
  {
    "doc_id": "arkts-sendable-module",
    "title": "共享模块",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-sendable-module.md",
    "summary": "共享模块是进程内只会加载一次的模块，使用\"use shared\"这一指令来标记一个模块是否为共享模块。 非共享模块在同一线程内只加载一次，而在不同线程中会多次加载，每个线程都会生成新的模块对象。因此，目前只能使用共享模块实现进程单例。 - \"use shared\"需要与\"use strict\"一样写在ArkTS文件顶层，写在import语句之后其他语句之前。",
    "key_topics": [
      "共享模块",
      "约束限制",
      "使用示例",
      "共享模块是进程内只会加载一次的模块，使用\"use shared\"这一指令来标记一个模块是否为共享模块"
    ],
    "sections": [
      "约束限制",
      "使用示例"
    ]
  },
  {
    "doc_id": "arkts-sendable",
    "title": "Sendable对象简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-sendable.md",
    "summary": "在传统JS引擎中，要优化对象的并发通信开销，唯一的方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低开销。然而，开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中尚未解决。 ArkTS提供了Sendable对象类型，在并发通信时支持通过引用传递来解决上述问题。 Sendable对象可共享，跨线程前后指向同一个JS对象。如果Sendable对象通过调用Napi接口与一个Native对象绑定，当共享传递Sendable对象时，其绑定的Native对象也会一并共享传递。通信过程如下图所示：",
    "key_topics": [
      "Sendable对象简介",
      "基础概念",
      "Sendable协议",
      "ISendable",
      "Sendable class"
    ],
    "sections": [
      "基础概念",
      "Sendable协议",
      "ISendable",
      "Sendable class",
      "Sendable function",
      "Sendable interface",
      "Sendable支持的数据类型",
      "Sendable的实现原理",
      "\\@Sendable装饰器"
    ]
  },
  {
    "doc_id": "arkts-utils-overview",
    "title": "ArkTS基础类库概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arkts-utils-overview.md",
    "summary": "ArkTS基础类库是一个功能齐全的API集合，设计了一系列关键且实用的功能模块。 ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，简化开发工作，提升开发效率。",
    "key_topics": [
      "ArkTS基础类库概述",
      "ArkTS基础类库是一个功能齐全的API集合，设计了一系列关键且实用的功能模块"
    ],
    "sections": []
  },
  {
    "doc_id": "arraybuffer-object",
    "title": "ArrayBuffer对象",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\arraybuffer-object.md",
    "summary": "ArrayBuffer包含两部分：底层存储数据的Native内存区域，以及封装操作的JS对象壳。JS对象壳分配在虚拟机的本地堆（LocalHeap）中。跨线程传递时，JS对象壳需要序列化和反序列化拷贝传递，而Native内存区域可以通过拷贝或转移的方式传递。 Native内存使用拷贝方式（递归遍历）传输时，传输后两个线程可以独立访问ArrayBuffer。此方式需要重建JS壳和拷贝Native内存，传输效率较低。通信过程如下图所示： ![copy_transfer](figures/copy_transfer.png)",
    "key_topics": [
      "ArrayBuffer对象",
      "ArrayBuffer拷贝传输方式",
      "ArrayBuffer转移传输方式",
      "ArrayBuffer包含两部分：底层存储数据的Native内存区域，以及封装操作的JS对象壳"
    ],
    "sections": [
      "ArrayBuffer拷贝传输方式",
      "ArrayBuffer转移传输方式"
    ]
  },
  {
    "doc_id": "ason-parsing-generation",
    "title": "ASON解析与生成",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\ason-parsing-generation.md",
    "summary": "[ASON工具](../reference/apis-arkts/arkts-apis-arkts-utils-ASON.md)与JS提供的JSON工具类似，JSON用于进行JS对象的序列化（stringify）、反序列化（parse）。ASON则提供了[Sendable对象](arkts-sendable.md)的序列化、反序列化能力。使用ASON.stringify方法可将对象转换为字符串，使用ASON.parse方法可将字符串转换为Sendable对象，从而实现对象在并发任务间的高性能引用传递。",
    "key_topics": [
      "ASON解析与生成",
      "使用示例"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "async-concurrency-overview",
    "title": "异步并发 (Promise和async/await)",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\async-concurrency-overview.md",
    "summary": "Promise和async/await是标准的JS异步语法，提供异步并发能力。异步代码执行时会被挂起，稍后继续执行，确保同一时间只有一段代码在运行。以下是典型的异步并发使用场景： - I/O 非阻塞操作：网络请求、文件读写、定时器等。 - 任务轻量且无 CPU 阻塞：单次任务执行时间短。",
    "key_topics": [
      "异步并发 (Promise和async/await)",
      "Promise",
      "async/await",
      "Promise和async/await是标准的JS异步语法，提供异步并发能力"
    ],
    "sections": [
      "Promise",
      "async/await"
    ]
  },
  {
    "doc_id": "batch-database-operations-guide",
    "title": "批量数据写数据库场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\batch-database-operations-guide.md",
    "summary": "对于需要频繁数据库操作的场景，由于读写数据库存在耗时，因此推荐在子线程中操作，避免阻塞UI线程。 通过ArkTS提供的TaskPool能力，可以将数据库操作任务移到子线程中，实现如下。 1. 创建多个子任务，支持数据库的创建、插入、查询和清除等操作。",
    "key_topics": [
      "批量数据写数据库场景",
      "使用TaskPool进行频繁数据库操作",
      "使用Sendable进行大容量数据库操作",
      "复杂类实例对象使用Sendable进行大容量数据库操作",
      "对于需要频繁数据库操作的场景，由于读写数据库存在耗时，因此推荐在子线程中操作，避免阻塞UI线程"
    ],
    "sections": [
      "使用TaskPool进行频繁数据库操作",
      "使用Sendable进行大容量数据库操作",
      "复杂类实例对象使用Sendable进行大容量数据库操作"
    ]
  },
  {
    "doc_id": "buffer",
    "title": "Buffer与FastBuffer",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\buffer.md",
    "summary": "Buffer和FastBuffer模块将内存区域抽象为可读写、修改的逻辑对象，提供高效的二进制数据处理接口。每个Buffer实例是连续的字节序列，支持创建自定义大小的内存块，用于存储和操作序列化后的数据。 Buffer和FastBuffer模块的主要应用场景包括： 1. **大数据传输**：传输大量数据，如二进制文件、数据库记录或网络报文时，使用Buffer作为数据的存储和处理容器，可减少拷贝和内存消耗，提升效率。",
    "key_topics": [
      "Buffer与FastBuffer",
      "场景介绍",
      "Buffer",
      "FastBuffer",
      "Buffer和FastBuffer模块将内存区域抽象为可读写、修改的逻辑对象，提供高效的二进制数据处理接口"
    ],
    "sections": [
      "场景介绍",
      "Buffer",
      "FastBuffer"
    ]
  },
  {
    "doc_id": "bytecode-obfuscation-guide",
    "title": "ArkGuard字节码混淆开启指南",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\bytecode-obfuscation-guide.md",
    "summary": "> **注意**： > > 为了避免后续修改代码影响现网问题分析定位，建议开发者在版本发布时，本地备份build/default/cache/default/default@XXXCompileArkTS/esmodule/release/obfuscation 路径下的全部内容； 有条件的可以直接备份release目录。 字节码混淆与源码混淆功能无法同时启用，开启字节码混淆后，源码混淆功能将自动关闭。 从API version 20开始，字节码混淆能力已在系统中集成，可通过以下方式在DevEco Studio开启使用。",
    "key_topics": [
      "ArkGuard字节码混淆开启指南",
      "字节码混淆开启步骤",
      "约束与限制",
      "开启混淆步骤",
      "三种混淆配置文件"
    ],
    "sections": [
      "字节码混淆开启步骤",
      "约束与限制",
      "开启混淆步骤",
      "三种混淆配置文件",
      "混淆选项配置指导",
      "说明",
      "查看混淆效果",
      "报错栈还原"
    ]
  },
  {
    "doc_id": "bytecode-obfuscation-overview",
    "title": "ArkGuard字节码混淆工具概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\bytecode-obfuscation-overview.md",
    "summary": "从API version 20开始，ArkGuard提供了基础字节码混淆能力，将代码中的函数名、类名、文件名等名字变成简短无意义的名字，提高通过阅读代码猜测其用途的难度。由于混淆后的工程源码中元素名称缩短，有时也可以通过混淆来降低包大小。 本章节详细介绍了ArkGuard字节码混淆工具的使用方法和特点，旨在帮助开发者高效地利用ArkGuard进行字节码混淆，从而提升代码的复杂度，增加逆向工程的难度。 相比源码混淆，字节码混淆的混淆对象是字节码文件。",
    "key_topics": [
      "ArkGuard字节码混淆工具概述",
      "从API version 20开始，ArkGuard提供了基础字节码混淆能力，将代码中的函数名、类名、文件名等名字变成简短无意义的名字，提高通过阅读代码猜测其用途的难度"
    ],
    "sections": []
  },
  {
    "doc_id": "bytecode-obfuscation-practice",
    "title": "不同包类型的字节码混淆建议",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\bytecode-obfuscation-practice.md",
    "summary": "由于不同包类型的用途及构建流程的差异，开发者对不同包类型使用混淆有不同的注意事项。本文对[HAP](../quick-start/hap-package.md)、[HAR](../quick-start/har-package.md)和[HSP](../quick-start/in-app-hsp.md)三种包类型分别提供建议，帮助开发者高效使用混淆。",
    "key_topics": [
      "不同包类型的字节码混淆建议",
      "推荐混淆选项",
      "HAP包混淆建议",
      "HAR包混淆建议",
      "HAR包通用建议"
    ],
    "sections": [
      "推荐混淆选项",
      "HAP包混淆建议",
      "HAR包混淆建议",
      "HAR包通用建议",
      "本地源码HAR包",
      "发布态源码HAR包",
      "发布态字节码HAR包",
      "HSP包混淆建议",
      "HSP包通用建议",
      "本地源码HSP包",
      "集成态HSP包"
    ]
  },
  {
    "doc_id": "bytecode-obfuscation-questions",
    "title": "ArkGuard字节码混淆常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\bytecode-obfuscation-questions.md",
    "summary": "**json文件** 字节码混淆在开启`-enable-filename-obfuscation`混淆项后，json文件名会参与混淆。 1. 字节码混淆开关，默认关闭，在[开启混淆功能](bytecode-obfuscation-guide.md#开启混淆步骤)后，需要额外在模块目录下`obfuscation-rules.txt`文件中配置`-enable-bytecode-obfuscation` 、`-enable-bytecode-obfuscation-debugging`。 2. 字节码混淆，不支持以下混淆项`-remove-comments`。 **目录差异**",
    "key_topics": [
      "ArkGuard字节码混淆常见问题",
      "字节码混淆与源码混淆差异",
      "混淆范围差异",
      "混淆选项差异",
      "混淆后文件结构差异"
    ],
    "sections": [
      "字节码混淆与源码混淆差异",
      "混淆范围差异",
      "混淆选项差异",
      "混淆后文件结构差异",
      "切换注意点",
      "如何排查功能异常",
      "常规配置问题处理",
      "开启enable-bytecode-obfuscation-debugging，没有生成pa文件如何处理",
      "混淆如何查看混淆效果",
      "编译报错处理",
      "运行异常处理",
      "开启-enable-property-obfuscation选项可能出现的问题",
      "同时开启-enable-export-obfuscation和-enable-toplevel-obfuscation选项可能出现的问题",
      "未开启-enable-string-property-obfuscation混淆选项，字符串字面量属性名却被混淆，导致字符串字面量属性名的值为undefined",
      "开启-enable-filename-obfuscation选项后，可能会出现的问题"
    ]
  },
  {
    "doc_id": "bytecode-obfuscation",
    "title": "ArkGuard字节码混淆原理及功能",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\bytecode-obfuscation.md",
    "summary": "| 名词 | 释义 | | -------- | -------- | |[HAP](../quick-start/hap-package.md)|HAP（Harmony Ability Package）是应用安装和运行的基本单元。HAP包是由代码、资源、第三方库、配置文件等打包生成的模块包。| |[HAR](../quick-start/har-package.md)|HAR（Harmony Archive）是静态共享包，通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。通过Static Library创建HAR模块。",
    "key_topics": [
      "ArkGuard字节码混淆原理及功能",
      "术语清单",
      "混淆生效范围",
      "适用语言",
      "混淆能力"
    ],
    "sections": [
      "术语清单",
      "混淆生效范围",
      "适用语言",
      "混淆能力",
      "混淆能力局限性",
      "混淆机制及流程",
      "混淆选项",
      "已有混淆选项汇总",
      "-disable-obfuscation",
      "-enable-property-obfuscation",
      "-enable-string-property-obfuscation",
      "-enable-toplevel-obfuscation",
      "-enable-export-obfuscation",
      "-enable-filename-obfuscation",
      "-compact",
      "-remove-log",
      "-print-namecache",
      "-apply-namecache",
      "-enable-lib-obfuscation-options",
      "-enable-bytecode-obfuscation",
      "-enable-bytecode-obfuscation-debugging",
      "保留选项",
      "已有保留选项汇总",
      "-keep-property-name",
      "-keep-global-name",
      "-keep-file-name",
      "-keep-dts",
      "-keep",
      "保留选项支持的通配符",
      "名称类通配符",
      "路径类通配符",
      "混淆规则合并策略",
      "混淆规则合并逻辑"
    ]
  },
  {
    "doc_id": "commonlibrary-faq",
    "title": "基础库常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\commonlibrary-faq.md",
    "summary": "由于ArkTS侧提供的XML解析接口暂不支持流式解析模式，建议通过Native工程调用第三方C/C++库来实现。推荐使用**libxml2**库，该库具有成熟稳定、性能优越的特点，能够完美支持SAX等流式解析方式，有效降低内存占用。 具体实施步骤如下： 1. **创建Native工程**：在OpenHarmony项目中创建C++模块。 2. **集成libxml2**：下载并配置libxml2库源码或预编译库，在`CMakeLists.txt`中进行引用。 3. **编写解析代码**：使用libxml2提供的API实现流式解析逻辑。",
    "key_topics": [
      "基础库常见问题",
      "解析大文件xml发生内存溢出（Out of Memory）",
      "由于ArkTS侧提供的XML解析接口暂不支持流式解析模式，建议通过Native工程调用第三方C/C++库来实现"
    ],
    "sections": [
      "解析大文件xml发生内存溢出（Out of Memory）"
    ]
  },
  {
    "doc_id": "compilation-tool-chain-overview",
    "title": "ArkTS编译工具链概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\compilation-tool-chain-overview.md",
    "summary": "ArkTS SDK提供了一套完整的编译工具链，以支持ArkTS的应用编译，通过集成至[Hvigor](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor)编译任务的编排工具上，实现将应用的ArkTS/TS/JS源码编译生成方舟字节码文件（\\*.abc）。 编译工具链在编译过程中首先执行语法转换，包括语法检查和UI转换。为确保源码安全，编译工具链使用[ArkGuard源码混淆工具](source-obfuscation.md)对源码进行混淆操作。",
    "key_topics": [
      "ArkTS编译工具链概述"
    ],
    "sections": []
  },
  {
    "doc_id": "concurrency-faq",
    "title": "并发常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\concurrency-faq.md",
    "summary": "开发者发现TaskPool任务不执行时，可按照以下步骤快速定位。 1. **taskpool.execute接口是否调用**。 taskpool.execute被调用时，Hilog会打印TaskPool调用态日志（Task Allocation: taskId:）。",
    "key_topics": [
      "并发常见问题",
      "TaskPool任务不执行快速定位指导",
      "TaskPool任务执行慢排查思路",
      "排查方向：晚执行的TaskPool任务是串行任务或者依赖其他任务",
      "排查方向：@Concurrent标记的方法所在的ets文件里import过多模块"
    ],
    "sections": [
      "TaskPool任务不执行快速定位指导",
      "TaskPool任务执行慢排查思路",
      "排查方向：出问题的TaskPool任务优先级较低，应用后续新增较多优先级更高的TaskPool任务，导致原有低优先级的TaskPool任务执行延后",
      "排查方向：晚执行的TaskPool任务是串行任务或者依赖其他任务",
      "排查方向：@Concurrent标记的方法所在的ets文件里import过多模块",
      "TaskPool序列化失败问题定位指导",
      "Sendable类A的实例对象a传递到子线程后，使用a instanceof A判断返回false",
      "使用Sendable特性抛JS异常排查指导",
      "属性类型不一致异常",
      "新增属性异常",
      "ArkTS提供的Promise能力的原理是什么",
      "TaskPool线程是否可以执行不需要@Concurrent和@Sendable修饰的JS闭包函数",
      "TaskPool任务执行后的结果如何保存到自定义的数据结构",
      "Sendable类在子线程无法加载"
    ]
  },
  {
    "doc_id": "concurrency-overview",
    "title": "并发概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\concurrency-overview.md",
    "summary": "并发指在同一时间内，多个任务同时执行。在多核设备上，任务可以在不同CPU上并行执行。对于单核设备，尽管多个任务不会同时执行，但CPU会在某个任务休眠或进行I/O操作时切换任务，调度其他任务，提高CPU的资源利用率。 为了提升应用的响应速度和帧率，避免耗时任务影响UI主线程，ArkTS提供了异步并发和多线程并发两种处理策略。 - 异步并发是指异步代码在执行到一定程度后暂停，并在未来某个时间点继续执行，同一时间只有一段代码执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务。",
    "key_topics": [
      "并发概述",
      "并发指在同一时间内，多个任务同时执行"
    ],
    "sections": []
  },
  {
    "doc_id": "concurrent-loading-modules-guide",
    "title": "业务模块并发加载场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\concurrent-loading-modules-guide.md",
    "summary": "在应用启动时，多个业务模块需要加载，例如地图应用中的定位、打车、导航等模块。如果全部在UI主线程初始化，会严重影响应用冷启动时间。此时，应在不同子线程中并行加载这些模块，以降低启动耗时。 通过使用ArkTS提供的TaskPool能力，可以将不同的业务初始化任务移到子线程中。业务模块可通过下沉C++实现为[NativeBinding对象](transferabled-object.md)或在ArkTS层定义为[Sendable对象](arkts-sendable.md)，从而将初始化的模块返回给UI主线程调用，实现如下。 1. 各业务功能（SDK）模块定义（这里以使用Sendable对象为例）。",
    "key_topics": [
      "业务模块并发加载场景",
      "在应用启动时，多个业务模块需要加载，例如地图应用中的定位、打车、导航等模块"
    ],
    "sections": []
  },
  {
    "doc_id": "container-object",
    "title": "容器类对象",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\container-object.md",
    "summary": "容器类对象在跨线程传递时，可通过序列化的形式，确保两个线程的内容一致，从而实现跨线程数据传递。 目前支持序列化的容器类对象包括[TreeSet](../reference/apis-arkts/js-apis-treeset.md)。 > **说明：** > > - 从OpenHarmony 6.1开始，支持使用TreeSet容器类对象实现跨线程数据传递。 > > - 容器类对象跨线程传递时，只能传递数据，自定义方法会丢失。",
    "key_topics": [
      "容器类对象",
      "使用示例",
      "容器类对象在跨线程传递时，可通过序列化的形式，确保两个线程的内容一致，从而实现跨线程数据传递"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "container-overview",
    "title": "容器类库概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\container-overview.md",
    "summary": "容器类库用于存储各种数据类型的元素，提供一系列处理数据的方法，作为纯数据结构容器具有一定的优势。 容器类使用静态语言实现，限制了存储位置和属性，不支持自定义属性和方法，确保每种类型的数据都能在完成自身功能的同时去除冗余逻辑，从而实现高效的数据访问，提升应用性能。 当前提供了线性和非线性两类容器。[线性容器](linear-container.md)和[非线性容器](nonlinear-container.md)均非多线程安全的。",
    "key_topics": [
      "容器类库概述",
      "容器类库用于存储各种数据类型的元素，提供一系列处理数据的方法，作为纯数据结构容器具有一定的优势"
    ],
    "sections": []
  },
  {
    "doc_id": "cpu-intensive-task-development",
    "title": "CPU密集型任务开发指导 (TaskPool和Worker)",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\cpu-intensive-task-development.md",
    "summary": "CPU密集型任务是指需要占用系统资源进行大量计算的任务，这类任务需要长时间运行，会阻塞线程中其他事件的处理，因此不适合在UI主线程中执行。例如图像处理、视频编码、数据分析等。 基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。 当任务不需要长时间（3分钟）占用后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。",
    "key_topics": [
      "CPU密集型任务开发指导 (TaskPool和Worker)",
      "使用TaskPool进行图像直方图处理",
      "使用Worker进行长时间数据分析",
      "CPU密集型任务是指需要占用系统资源进行大量计算的任务，这类任务需要长时间运行，会阻塞线程中其他事件的处理，因此不适合在UI主线程中执行"
    ],
    "sections": [
      "使用TaskPool进行图像直方图处理",
      "使用Worker进行长时间数据分析"
    ]
  },
  {
    "doc_id": "customize-bytecode-during-compilation",
    "title": "编译期自定义修改方舟字节码",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\customize-bytecode-during-compilation.md",
    "summary": "如果开发者希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的方法自定义修改方舟字节码文件。 准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md#transformlib)，选项值为这个动态库的路径，编译器会在指定时机加载该动态库，并执行其中指定的Transform方法。",
    "key_topics": [
      "编译期自定义修改方舟字节码",
      "能力配置说明",
      "能力执行机制",
      "开发示例",
      "如果开发者希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的方法自定义修改方舟字节码文件"
    ],
    "sections": [
      "能力配置说明",
      "能力执行机制",
      "开发示例"
    ]
  },
  {
    "doc_id": "es2abc-faq",
    "title": "方舟字节码生成常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\es2abc-faq.md",
    "summary": "在ArkTS工程的构建流程中，方舟字节码（*.abc）的生成由工具链中的es2abc编译器组件完成。 在Hvigor构建任务中，es2abc编译器会被自动调用，用于将TypeScript/JavaScript源代码转换为方舟虚拟机能够执行的字节码文件（*.abc）。这些生成的文件随后被打包进HAP/HAR/HSP中，并由系统加载。 本FAQ汇总了字节码生成在实际编译中常见的异常场景，并提供原因分析与排查方式，帮助开发者更高效定位字节码编译阶段的问题。",
    "key_topics": [
      "方舟字节码生成常见问题",
      "字节码生成流程",
      "编译时报owns a higher api version错误",
      "编译异常，无具体错误日志",
      "在ArkTS工程的构建流程中，方舟字节码（*.abc）的生成由工具链中的es2abc编译器组件完成"
    ],
    "sections": [
      "字节码生成流程",
      "编译时报owns a higher api version错误",
      "编译时报Field {&harname/Index&1.0.0.moduleRecordIdx} has different value错误",
      "编译异常，无具体错误日志"
    ]
  },
  {
    "doc_id": "gc-introduction",
    "title": "GC垃圾回收",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\gc-introduction.md",
    "summary": "GC（全称 Garbage Collection），即垃圾回收。在计算机领域，GC是指识别并释放内存中的不再使用的对象，以回收内存空间。目前广泛使用的编程语言实现的GC算法主要分为两大类：引用计数和对象追踪（即Tracing GC）。 **引用计数** 当对象B指向对象A时，A的引用计数加1；当该指向断开时，A的引用计数减1。如果A的引用计数为0，则回收对象A。",
    "key_topics": [
      "GC垃圾回收",
      "GC算法简述",
      "GC的类型",
      "对象追踪的三种类型",
      "HPP GC"
    ],
    "sections": [
      "GC算法简述",
      "GC的类型",
      "对象追踪的三种类型",
      "HPP GC",
      "Heap结构及其配置参数",
      "Heap结构",
      "相关参数",
      "GC流程",
      "HPP GC的类型",
      "触发策略",
      "执行策略",
      "SharedHeap",
      "SharedHeap结构",
      "特性",
      "Smart GC",
      "日志解释",
      "开启全量日志",
      "典型日志",
      "GC开发者调试接口",
      "ArkTools.hintGC()",
      "GC常见问题",
      "GC稳定性问题排查指导"
    ]
  },
  {
    "doc_id": "global-configuration-guide",
    "title": "全局配置项功能场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\global-configuration-guide.md",
    "summary": "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项功能，可以采用[共享模块](arkts-sendable-module.md)来实现。 以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的功能，具体步骤如下。 1. 编写全局配置文件。",
    "key_topics": [
      "全局配置项功能场景",
      "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项功能，可以采用[共享模块](arkts-sendable-module.md)来实现"
    ],
    "sections": []
  },
  {
    "doc_id": "independent-time-consuming-task",
    "title": "使用TaskPool执行独立的耗时任务",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\independent-time-consuming-task.md",
    "summary": "对于独立运行的耗时任务，任务完成后将结果返回给宿主线程。可采用以下方式实现。 下面通过图片加载来说明。 1. 实现子线程需要执行的任务。",
    "key_topics": [
      "使用TaskPool执行独立的耗时任务",
      "对于独立运行的耗时任务，任务完成后将结果返回给宿主线程"
    ],
    "sections": []
  },
  {
    "doc_id": "interthread-communication-overview",
    "title": "ArkTS线程间通信概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\interthread-communication-overview.md",
    "summary": "线程间通信指并发多线程间的数据交换行为。由于ArkTS语言兼容TS/JS，其运行时实现与其它JS引擎一样，采用基于Actor内存隔离的并发模型。 在ArkTS线程间通信中，不同数据对象的行为存在差异。例如，普通JS对象、ArrayBuffer对象和SharedArrayBuffer对象在跨线程时的处理方式不同，涉及序列化、反序列化、数据转移和数据共享等操作。 以JS对象为例，其在并发任务间的通信采用了标准的Structured Clone算法（序列化和反序列化）。",
    "key_topics": [
      "ArkTS线程间通信概述",
      "线程间通信指并发多线程间的数据交换行为"
    ],
    "sections": []
  },
  {
    "doc_id": "io-intensive-task-development",
    "title": "I/O密集型任务开发指导 (TaskPool)",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\io-intensive-task-development.md",
    "summary": "使用异步并发可以解决单次I/O任务阻塞的问题。对于I/O密集型任务，若线程中的其他任务仍可能被阻塞，建议采用多线程并发来处理。 I/O密集型任务的性能关键在于I/O操作的速度和效率，而非CPU的处理能力。这类任务需要频繁进行磁盘读写和网络通信。此处通过频繁读写系统文件来模拟I/O密集型并发任务的处理。 1. 定义并发函数，内部密集调用I/O能力。",
    "key_topics": [
      "I/O密集型任务开发指导 (TaskPool)",
      "使用异步并发可以解决单次I/O任务阻塞的问题"
    ],
    "sections": []
  },
  {
    "doc_id": "js-apis-load-native-module",
    "title": "同步方式动态加载Native模块",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\js-apis-load-native-module.md",
    "summary": "[loadNativeModule接口](../reference/common/js-apis-common-load-native-module.md)用于同步动态加载Native模块，目的是按需加载所需要的模块。使用该接口会增加加载so文件的时间，开发者需评估其对功能的影响。",
    "key_topics": [
      "同步方式动态加载Native模块",
      "函数说明",
      "loadNativeModule支持的场景",
      "使用示例"
    ],
    "sections": [
      "函数说明",
      "loadNativeModule支持的场景",
      "使用示例"
    ]
  },
  {
    "doc_id": "linear-container",
    "title": "线性容器",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\linear-container.md",
    "summary": "线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。 线性容器优化了数据访问速度，运行时（Runtime）通过一条字节码指令即可完成增、删、改、查等操作。 | 类名 | 特征及建议使用场景 | | --------- | ------- | | ArrayList | 动态数组，占用一片连续的内存空间。需要频繁读取元素时推荐使用。 | | List | 单向链表，占用的空间可以不连续。推荐在需要频繁插入和删除元素，且需要使用单向链表时使用。",
    "key_topics": [
      "线性容器",
      "各线性容器类型特征对比",
      "ArrayList",
      "List",
      "LinkedList"
    ],
    "sections": [
      "各线性容器类型特征对比",
      "ArrayList",
      "List",
      "LinkedList",
      "Deque",
      "Queue",
      "Stack",
      "Vector",
      "线性容器的使用"
    ]
  },
  {
    "doc_id": "load-module-base-nodeapi",
    "title": "基于Node-API加载模块",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\load-module-base-nodeapi.md",
    "summary": "Node-API中有多种方式支持开发者在C++侧加载工程内模块及文件。推荐使用napi_load_module_with_info接口。 在主线程或子线程内加载hap/hsp/har/native模块，使用时必须标记所加载的包的信息，支持多种场景。 具体参考：[napi_load_module_with_info](../napi/use-napi-load-module-with-info.md)。",
    "key_topics": [
      "基于Node-API加载模块",
      "napi_load_module_with_info",
      "napi_load_module",
      "Node-API中有多种方式支持开发者在C++侧加载工程内模块及文件"
    ],
    "sections": [
      "napi_load_module_with_info",
      "napi_load_module"
    ]
  },
  {
    "doc_id": "long-time-task-guide",
    "title": "长时任务开发指导（TaskPool）",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\long-time-task-guide.md",
    "summary": "此处提供使用TaskPool进行长时任务的开发指导，以定期采集传感器数据为例。 1. 导入所需的模块。 ```ts // Index.ets import { sensor } from '@kit.SensorServiceKit'; import { taskpool } from '@kit.ArkTS'; import { BusinessError, emitter } from '@kit.BasicServicesKit'; ```",
    "key_topics": [
      "长时任务开发指导（TaskPool）",
      "使用TaskPool进行传感器数据监听",
      "此处提供使用TaskPool进行长时任务的开发指导，以定期采集传感器数据为例"
    ],
    "sections": [
      "使用TaskPool进行传感器数据监听"
    ]
  },
  {
    "doc_id": "long-time-task-overview",
    "title": "长时任务并发场景简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\long-time-task-overview.md",
    "summary": "在应用业务实现过程中，需要较长时间不定时运行的任务称为长时任务。如果在UI主线程中执行这些长时任务，会阻塞UI业务，导致卡顿和丢帧等问题，影响用户体验。因此，通常需要将这些独立的长时任务放到单独的子线程中执行。 典型的长时任务场景如下所示： | 常见业务场景 | 具体业务描述 | | -------- | -------- | | 定期采集传感器数据 | 周期性采集一些传感器信息（例如位置信息、速度传感器等），应用需要长时间不间断的运行。 | | 监听Socket端口信息 | 长时间监听Socket数据，不定时需要响应处理。 |",
    "key_topics": [
      "长时任务并发场景简介",
      "在应用业务实现过程中，需要较长时间不定时运行的任务称为长时任务"
    ],
    "sections": []
  },
  {
    "doc_id": "makeobserved-sendable",
    "title": "ArkUI数据更新场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\makeobserved-sendable.md",
    "summary": "当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。 本示例说明以下场景： - makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI更新。",
    "key_topics": [
      "ArkUI数据更新场景"
    ],
    "sections": []
  },
  {
    "doc_id": "module-principle",
    "title": "模块化运行简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\module-principle.md",
    "summary": "为了解决大型或复杂应用开发过程中，部分代码编译时被多次拷贝导致包体积增大、文件依赖、代码与资源共享困难以及单例和全局变量污染等问题，ArkTS支持应用模块化编译、打包和运行，简化代码的编写与维护。 模块化是将ArkTS/TS/JS模块（一个文件对应一个模块）以及so模块通过编译工具或运行时机制将这些[模块加载](#模块化运行加载流程)、解析、组合并执行的过程。 ArkTS支持的模块类型包括ets/ts/js文件、json文件、Native模块。",
    "key_topics": [
      "模块化运行简介",
      "模块化运行加载流程",
      "ArkTS支持的模块化规范",
      "ECMAScript模块",
      "CommonJS模块"
    ],
    "sections": [
      "模块化运行加载流程",
      "ArkTS支持的模块化规范",
      "ECMAScript模块",
      "CommonJS模块",
      "CommonJS与ES Module支持规格",
      "ArkTS支持加载的模块类型",
      "ets/ts/js",
      "JSON文件",
      "Native模块"
    ]
  },
  {
    "doc_id": "multi-thread-cancel-task",
    "title": "多线程取消TaskPool任务场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\multi-thread-cancel-task.md",
    "summary": "由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，无法在子线程中直接取消任务。从 API version 18 开始，Task新增了[任务ID](../reference/apis-arkts/js-apis-taskpool.md#属性)属性，支持通过任务ID在子线程中取消任务。",
    "key_topics": [
      "多线程取消TaskPool任务场景"
    ],
    "sections": []
  },
  {
    "doc_id": "multi-thread-concurrency-overview",
    "title": "多线程并发概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\multi-thread-concurrency-overview.md",
    "summary": "多线程并发是指在单个程序中同时运行多个线程，通过并行或交替执行任务来提升性能和资源利用率的编程模型。在ArkTS应用开发中，多线程并发适用于多种业务场景，常见的业务场景主要分为以下三类，更详细的使用请参考[多线程开发实践案例](batch-database-operations-guide.md)。 - 业务逻辑包含大量计算或频繁的I/O读写等需要长时间执行的任务，例如图片和视频的编解码、文件的压缩与解压缩、数据库操作等场景。 - 业务逻辑包括监听和定期采集数据等需要长时间保持运行的任务，例如定期采集传感器数据的场景。",
    "key_topics": [
      "多线程并发概述",
      "多线程并发模型",
      "内存共享模型",
      "Actor模型",
      "TaskPool和Worker"
    ],
    "sections": [
      "多线程并发模型",
      "内存共享模型",
      "Actor模型",
      "TaskPool和Worker",
      "并发注意事项"
    ]
  },
  {
    "doc_id": "multi-time-consuming-tasks",
    "title": "使用TaskPool执行多个耗时任务",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\multi-time-consuming-tasks.md",
    "summary": "多个任务同时执行时，由于任务复杂度不同，执行时间和返回数据的时间也会不同。如果宿主线程需要所有任务执行完毕的数据，可以通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。 除了以上情况，如果需要处理的数据量较大，例如一个列表中有10000条数据，将这些数据放在一个Task中处理会非常耗时。那么就可以将原始数据拆分成多个子列表，为每个子列表分配一个独立的Task执行，等待全部Task执行完成后合并结果形成完整的数据，这样可以节省处理时间，提升用户体验。 下面以多个任务进行图片加载为例进行说明。",
    "key_topics": [
      "使用TaskPool执行多个耗时任务",
      "多个任务同时执行时，由于任务复杂度不同，执行时间和返回数据的时间也会不同"
    ],
    "sections": []
  },
  {
    "doc_id": "multithread-develop-overview",
    "title": "应用多线程开发概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\multithread-develop-overview.md",
    "summary": "在ArkTS应用开发中，不同业务场景需要不同的并发能力和任务类型。 常见的业务场景分为三种并发任务： [耗时任务](time-consuming-task-overview.md)：业务逻辑包含较大计算量或多次I/O读写等需要长时间执行的任务。",
    "key_topics": [
      "应用多线程开发概述",
      "在ArkTS应用开发中，不同业务场景需要不同的并发能力和任务类型"
    ],
    "sections": []
  },
  {
    "doc_id": "napi-coerce-to-native-binding-object",
    "title": "自定义Native Transferable对象的多线程操作场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\napi-coerce-to-native-binding-object.md",
    "summary": "在ArkTS应用开发中，有很多场景需要将ArkTS对象与Native对象进行绑定。ArkTS对象将数据写入Native对象，Native对象再将数据写入目的地。例如，将ArkTS对象中的数据写入C++数据库场景。 Native Transferable对象有两种模式：共享模式和转移模式。本示例将详细说明如何实现这两种模式。 1. Native实现各项功能。",
    "key_topics": [
      "自定义Native Transferable对象的多线程操作场景",
      "在ArkTS应用开发中，有很多场景需要将ArkTS对象与Native对象进行绑定"
    ],
    "sections": []
  },
  {
    "doc_id": "napi-define-sendable-object",
    "title": "自定义Native Sendable对象的多线程操作场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\napi-define-sendable-object.md",
    "summary": "ArkTS支持开发者自定义Native Sendable对象，Sendable对象提供了并发实例间高效的通信能力，即引用传递，适用于开发者自定义大对象需要线程间通信的场景，例如子线程读取数据库数据并返回给宿主线程。 本示例将详细说明如何使用自定义Native Sendable对象实现并发实例间数据共享。 1. 接口声明中自定义Sendable类。",
    "key_topics": [
      "自定义Native Sendable对象的多线程操作场景"
    ],
    "sections": []
  },
  {
    "doc_id": "native-interthread-shared",
    "title": "C++线程间数据共享场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\native-interthread-shared.md",
    "summary": "在C++层进行多线程并发计算时，需要在每个C++线程上创建ArkTS执行环境，直接调用API。这样可以避免在非UI主线程回调时等待UI主线程的API调用结果。同时，还需要在C++线程之间共享和操作Sendable对象。 为了支持此类场景，C++线程需要能够创建并调用ArkTS，同时支持对Sendable对象进行多线程共享和操作。 使用Node-API接口在C++线程中创建ArkTS运行环境并调用的方法，可以参考[使用Node-API接口创建ArkTS运行时环境](../napi/use-napi-ark-runtime.md)。",
    "key_topics": [
      "C++线程间数据共享场景",
      "在C++线程上调用ArkTS能力",
      "在C++线程之间操作Sendable共享对象",
      "在C++层进行多线程并发计算时，需要在每个C++线程上创建ArkTS执行环境，直接调用API"
    ],
    "sections": [
      "在C++线程上调用ArkTS能力",
      "在C++线程之间操作Sendable共享对象"
    ]
  },
  {
    "doc_id": "nonlinear-container",
    "title": "非线性容器",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\nonlinear-container.md",
    "summary": "非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。 | 类名 | 特征及建议使用场景 | | --------- | ------- | | HashMap | 存储具有关联关系的键值对集合。键唯一，依据键的hash值确定存储位置。访问速度快，但不能自定义排序。推荐用于需要快速存取、插入删除键值对数据时使用。 | | HashSet | 存储一系列值的集合。",
    "key_topics": [
      "非线性容器",
      "各非线性容器类型特征对比",
      "HashMap",
      "HashSet",
      "TreeMap"
    ],
    "sections": [
      "各非线性容器类型特征对比",
      "HashMap",
      "HashSet",
      "TreeMap",
      "TreeSet",
      "LightWeightMap",
      "LightWeightSet",
      "PlainArray",
      "非线性容器的使用"
    ]
  },
  {
    "doc_id": "normal-object",
    "title": "普通对象",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\normal-object.md",
    "summary": "普通对象跨线程时通过拷贝（序列化）形式传递，两个线程的对象内容一致，但指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）。序列化支持类型包括：除Symbol之外的基础类型、Date、String、RegExp、Array、Map、Set、Object（仅限简单对象，比如通过\"{}\"或者\"new Object\"创建，普通对象仅支持传递属性，不支持传递其原型及方法）、ArrayBuffer、TypedArray。",
    "key_topics": [
      "普通对象",
      "使用示例",
      "普通对象跨线程时通过拷贝（序列化）形式传递，两个线程的对象内容一致，但指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "resident-task-guide",
    "title": "常驻任务开发指导（Worker）",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\resident-task-guide.md",
    "summary": "提供使用Worker进行常驻任务的开发指导。Worker将持续执行任务，直到宿主线程发送终止指令。 开发过程和示例如下： 1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，单击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。",
    "key_topics": [
      "常驻任务开发指导（Worker）",
      "提供使用Worker进行常驻任务的开发指导"
    ],
    "sections": []
  },
  {
    "doc_id": "resident-task-overview",
    "title": "常驻任务并发场景简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\resident-task-overview.md",
    "summary": "在应用业务实现中，对于耗时较长（超过3分钟）且并发量较小的常驻任务，建议使用Worker在后台线程中执行这些操作，以避免阻塞UI主线程，防止出现丢帧、卡顿等影响用户体验的问题。 常驻任务是指相比于短时任务，时间更长的任务，可能跟UI主线程生命周期一致。相比于长时任务，常驻任务更倾向于跟线程绑定的任务，单次运行时间更长（比如超过3分钟）。 对于常驻任务，较为常见的业务场景如下：",
    "key_topics": [
      "常驻任务并发场景简介",
      "在应用业务实现中，对于耗时较长（超过3分钟）且并发量较小的常驻任务，建议使用Worker在后台线程中执行这些操作，以避免阻塞UI主线程，防止出现丢帧、卡顿等影响用户体验的问题"
    ],
    "sections": []
  },
  {
    "doc_id": "sendable-constraints",
    "title": "Sendable使用规则与约束",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\sendable-constraints.md",
    "summary": "Sendable对象的布局和原型链不可变，而非Sendable对象可以通过特殊方式修改布局。因此，不允许互相继承。这里的类不包含变量，Sendable类不能继承自变量。 **正例：** ```ts @Sendable class A { constructor() { } }",
    "key_topics": [
      "Sendable使用规则与约束",
      "继承规则",
      "Sendable类必须继承自Sendable类",
      "非Sendable类必须继承自非Sendable类",
      "接口实现规则"
    ],
    "sections": [
      "继承规则",
      "Sendable类必须继承自Sendable类",
      "非Sendable类必须继承自非Sendable类",
      "接口实现规则",
      "非Sendable类禁止实现Sendable接口",
      "Sendable类/接口成员变量规则",
      "必须是Sendable支持的数据类型",
      "不支持使用!断言",
      "不支持使用计算属性名",
      "不支持使用类型别名",
      "泛型规则",
      "泛型类中的Sendable类、SendableLruCache、collections.Array、collections.Map和collections.Set的模板类型必须是Sendable类型",
      "上下文访问规则",
      "Sendable类的内部不允许使用当前模块内上下文环境中定义的变量",
      "\\@Sendable装饰器使用规则",
      "\\@Sendable装饰器仅支持修饰类和函数",
      "Sendable类和Sendable函数禁止使用除\\@Sendable外的装饰器",
      "支持在Sendable class上叠加自定义装饰器",
      "初始化规则",
      "禁止使用对象字面量/数组字面量初始化Sendable对象",
      "类型转换规则",
      "禁止非Sendable类型强制转换为Sendable",
      "函数规则",
      "箭头函数不可标记为Sendable",
      "与TS/JS交互的规则",
      "ArkTS通用规则（目前只针对Sendable对象）",
      "NAPI规则（目前只针对Sendable对象）",
      "与UI交互的规则",
      "在HAR包中的使用规则"
    ]
  },
  {
    "doc_id": "sendable-freeze",
    "title": "Sendable对象冻结",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\sendable-freeze.md",
    "summary": "Sendable对象支持冻结操作。冻结后，对象变为只读，不能修改属性。因此，多个并发实例间访问时无需加锁。可以通过调用[Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)接口冻结对象。 > **说明：** > > 不支持在.ets文件中使用Object.freeze接口。 1. 提供ts文件封装Object.freeze方法。",
    "key_topics": [
      "Sendable对象冻结",
      "使用示例",
      "Sendable对象支持冻结操作"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "sendable-guide",
    "title": "Sendable使用场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\sendable-guide.md",
    "summary": "Sendable对象在不同并发实例间默认采用引用传递，这种方式比序列化更高效，且不会丢失类成员方法。因此，Sendable能够解决两个关键场景的问题： - 跨并发实例传输大数据（例如达到100KB以上的数据）。 - 跨并发实例传递带方法的class实例对象。",
    "key_topics": [
      "Sendable使用场景",
      "跨并发实例传输大数据场景",
      "跨并发实例传递带方法的class实例对象",
      "Sendable对象在不同并发实例间默认采用引用传递，这种方式比序列化更高效，且不会丢失类成员方法"
    ],
    "sections": [
      "跨并发实例传输大数据场景",
      "跨并发实例传递带方法的class实例对象"
    ]
  },
  {
    "doc_id": "sendablelrucache-recent-list",
    "title": "获取最近访问列表场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\sendablelrucache-recent-list.md",
    "summary": "为了快速访问最近使用的[Sendable](arkts-sendable.md)对象，从API version 18开始，ArkTS引入了[SendableLruCache](../reference/apis-arkts/arkts-apis-arkts-utils-SendableLruCache.md)。开发者可以通过向SendableLruCache实例中添加、删除和获取Sendable对象，实现快速访问最近使用的Sendable对象。",
    "key_topics": [
      "获取最近访问列表场景"
    ],
    "sections": []
  },
  {
    "doc_id": "serializable-overview",
    "title": "线程间通信对象概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\serializable-overview.md",
    "summary": "在多线程并发场景中，例如通过TaskPool或Worker创建后台线程，不同线程间需要进行数据交互。由于线程间内存隔离，线程间通信对象必须通过序列化实现值拷贝或内存共享。 > **说明：** > > - 单次序列化传输的数据量大小限制为16MB。 > - 序列化不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。",
    "key_topics": [
      "线程间通信对象概述",
      "在多线程并发场景中，例如通过TaskPool或Worker创建后台线程，不同线程间需要进行数据交互"
    ],
    "sections": []
  },
  {
    "doc_id": "shared-arraybuffer-object",
    "title": "SharedArrayBuffer对象",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\shared-arraybuffer-object.md",
    "summary": "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可用于多个并发实例间的状态或数据共享。通信过程如下图所示： ![sharedarraybuffer](figures/sharedarraybuffer.png) 使用TaskPool传递Int32Array对象，实现如下：",
    "key_topics": [
      "SharedArrayBuffer对象",
      "使用示例",
      "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）"
    ],
    "sections": [
      "使用示例"
    ]
  },
  {
    "doc_id": "source-obfuscation-guide",
    "title": "ArkGuard混淆开启指南",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\source-obfuscation-guide.md",
    "summary": "系统已集成源码混淆功能，开发者可通过以下方式在DevEco Studio中启用。 * 开启混淆开关 在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。 ``` JSON5 \"arkOptions\": { \"obfuscation\": { \"ruleOptions\": { \"enable\": true, // 开启混淆开关。 \"files\": [\"./obfuscation-rules.txt\"] // 指定配置混淆规则文件, 在编译本模块时生效。",
    "key_topics": [
      "ArkGuard混淆开启指南",
      "开启源码混淆",
      "开启混淆步骤",
      "三种混淆配置文件",
      "混淆选项配置指导"
    ],
    "sections": [
      "开启源码混淆",
      "开启混淆步骤",
      "三种混淆配置文件",
      "混淆选项配置指导",
      "说明",
      "查看混淆效果",
      "报错栈还原"
    ]
  },
  {
    "doc_id": "source-obfuscation-overview",
    "title": "ArkGuard源码混淆工具概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\source-obfuscation-overview.md",
    "summary": "ArkGuard是一款源码混淆工具，提供基础混淆功能。它将代码中的变量名、函数名、类名、文件名等替换为简短无意义的标识符，增加通过阅读代码推测其功能的难度。混淆后，工程源码中的元素名称简化，有助于减小程序包的体积。 本章节介绍ArkGuard源码混淆工具的使用方法和特点，帮助开发者高效利用ArkGuard进行源码混淆，提升代码复杂度，增加逆向工程难度。 - [ArkGuard混淆原理及功能](source-obfuscation.md)：说明混淆能力范围、混淆流程机制、混淆选项和保留选项的使用方法、以及混淆规则的合并策略，以及混淆各功能起始API版本。",
    "key_topics": [
      "ArkGuard源码混淆工具概述",
      "ArkGuard是一款源码混淆工具，提供基础混淆功能"
    ],
    "sections": []
  },
  {
    "doc_id": "source-obfuscation-practice",
    "title": "不同包类型的源码混淆建议",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\source-obfuscation-practice.md",
    "summary": "不同包类型的用途和构建流程存在差异，对不同包类型使用混淆时，开发者需要注意不同事项。本文针对[HAP](../quick-start/hap-package.md)、[HAR](../quick-start/har-package.md)和[HSP](../quick-start/in-app-hsp.md)三种包类型，分别提供混淆建议，帮助开发者高效使用混淆。",
    "key_topics": [
      "不同包类型的源码混淆建议",
      "推荐混淆功能",
      "HAP包混淆建议",
      "HAR包混淆建议",
      "HAR包通用建议"
    ],
    "sections": [
      "推荐混淆功能",
      "HAP包混淆建议",
      "HAR包混淆建议",
      "HAR包通用建议",
      "本地源码HAR包",
      "发布态源码HAR包",
      "发布态字节码HAR包",
      "HSP包源码混淆",
      "HSP包通用建议",
      "本地源码HSP包",
      "集成态HSP包"
    ]
  },
  {
    "doc_id": "source-obfuscation-questions",
    "title": "ArkGuard混淆常见问题",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\source-obfuscation-questions.md",
    "summary": "1. 在`obfuscation-rules.txt`中配置`-disable-obfuscation`选项关闭混淆，确认问题是否由混淆引起。 2. 若确认开启混淆后功能出现异常，请先阅读文档，了解模块已配置的混淆规则的能力和需要配置白名单的语法场景，以确保应用功能正常。下文简要介绍默认开启的四项选项功能，详情请参阅对应选项的完整描述。 1. [-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)为顶层作用域名称混淆开关。",
    "key_topics": [
      "ArkGuard混淆常见问题",
      "如何排查功能异常",
      "排查功能异常步骤",
      "排查非预期的混淆能力",
      "典型报错案例及解决方案"
    ],
    "sections": [
      "如何排查功能异常",
      "排查功能异常步骤",
      "排查非预期的混淆能力",
      "典型报错案例及解决方案",
      "报错信息为：Error message: Cannot read property xxx of undefined",
      "报错信息为：Error message: is not callable",
      "报错信息为：'module1/file1' does not provide an export name 'x', which is imported by 'module2/file2'",
      "应用运行后无crash信息，但功能异常的情况",
      "使用Record<string, Object>作为对象的类型定义时，属性被混淆",
      "跨文件调用某属性，该属性在一个文件中保留，在另一个文件中被混淆",
      "未开启-enable-string-property-obfuscation，字符串字面量属性名却被混淆",
      "数据库相关的字段被混淆后导致功能异常"
    ]
  },
  {
    "doc_id": "source-obfuscation",
    "title": "ArkGuard混淆原理及功能",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\source-obfuscation.md",
    "summary": "| 名词 | 释义 | | --- | --- | | [HAP](../quick-start/hap-package.md) | HAP（Harmony Ability Package）是应用安装和运行的基本单元。HAP包是由代码、资源、第三方库、配置文件等打包生成的模块包。 | | [HAR](../quick-start/har-package.md) | HAR（Harmony Archive）是静态共享包，通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。通过Static Library创建HAR模块。",
    "key_topics": [
      "ArkGuard混淆原理及功能",
      "术语清单",
      "混淆能力范围",
      "适用语言",
      "混淆能力"
    ],
    "sections": [
      "术语清单",
      "混淆能力范围",
      "适用语言",
      "混淆能力",
      "混淆能力局限性",
      "混淆机制及流程",
      "混淆选项",
      "已有混淆选项汇总",
      "默认混淆",
      "-disable-obfuscation",
      "-enable-property-obfuscation",
      "-enable-string-property-obfuscation",
      "-enable-toplevel-obfuscation",
      "-enable-export-obfuscation",
      "-enable-filename-obfuscation",
      "-compact",
      "-remove-comments",
      "-remove-log",
      "-print-namecache",
      "-apply-namecache",
      "-print-kept-names",
      "-extra-options strip-language-default",
      "-extra-options strip-system-api-args",
      "-extra-options strip-not-compiled-module-name",
      "-keep-parameter-names",
      "-enable-lib-obfuscation-options",
      "-use-keep-in-source",
      "-keep-object-props",
      "-remove-nosideeffects-calls",
      "保留选项",
      "已有保留选项汇总",
      "-keep-property-name",
      "-keep-global-name",
      "-keep-file-name",
      "-keep-comments",
      "-keep-dts",
      "-keep",
      "保留选项支持的通配符",
      "混淆规则合并策略",
      "混淆各功能起始API版本"
    ]
  },
  {
    "doc_id": "sync-task-development",
    "title": "同步任务开发指导 (TaskPool和Worker)",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\sync-task-development.md",
    "summary": "同步任务用于在多个线程间协调执行，确保任务按特定顺序和规则进行（如使用锁防止数据竞争）。 同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。 当同步任务之间相对独立时，推荐使用TaskPool，例如一系列导入的静态方法或单例实现的方法。如果同步任务之间有关联性，则需要使用Worker。",
    "key_topics": [
      "同步任务开发指导 (TaskPool和Worker)",
      "使用TaskPool处理同步任务",
      "使用Worker处理关联的同步任务",
      "同步任务用于在多个线程间协调执行，确保任务按特定顺序和规则进行（如使用锁防止数据竞争）"
    ],
    "sections": [
      "使用TaskPool处理同步任务",
      "使用Worker处理关联的同步任务"
    ]
  },
  {
    "doc_id": "taskpool-async-task-guide",
    "title": "TaskPool指定任务并发度场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\taskpool-async-task-guide.md",
    "summary": "TaskPool支持使用异步队列来控制任务的并发度，能有效避免资源过载，减少任务阻塞，适用于网络请求、视频流处理和数据库操作等场景。 此处提供使用TaskPool创建[异步队列](../reference/apis-arkts/js-apis-taskpool.md#asyncrunner18)的开发指导，以相机预览流采集数据处理的功能为例。 由于处理过程是一个频繁且耗时的任务，当相机采集速度过快时，将丢弃之前的采集数据，仅保留最新的一帧数据进行处理。",
    "key_topics": [
      "TaskPool指定任务并发度场景",
      "TaskPool支持使用异步队列来控制任务的并发度，能有效避免资源过载，减少任务阻塞，适用于网络请求、视频流处理和数据库操作等场景"
    ],
    "sections": []
  },
  {
    "doc_id": "taskpool-communicates-with-mainthread",
    "title": "TaskPool任务与宿主线程通信",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\taskpool-communicates-with-mainthread.md",
    "summary": "如果Task不仅需要返回最终执行结果，还需定时通知宿主线程状态和数据变化，或分段返回大量数据（如从数据库读取大量数据），可按以下方式实现。 下面以多个图片加载任务结果实时返回为例说明。 1. 实现接收Task消息的方法。",
    "key_topics": [
      "TaskPool任务与宿主线程通信",
      "如果Task不仅需要返回最终执行结果，还需定时通知宿主线程状态和数据变化，或分段返回大量数据（如从数据库读取大量数据），可按以下方式实现"
    ],
    "sections": []
  },
  {
    "doc_id": "taskpool-introduction",
    "title": "TaskPool简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\taskpool-introduction.md",
    "summary": "TaskPool为应用程序提供多线程环境，降低资源消耗并提高系统性能。无需管理线程生命周期。具体接口信息及使用方法，请参见[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)。 TaskPool运作机制示意图 ![zh-cn_image_0000001964858368](figures/zh-cn_image_0000001964858368.png)",
    "key_topics": [
      "TaskPool简介",
      "TaskPool运作机制",
      "TaskPool注意事项",
      "\\@Concurrent装饰器",
      "装饰器使用示例"
    ],
    "sections": [
      "TaskPool运作机制",
      "TaskPool注意事项",
      "\\@Concurrent装饰器",
      "装饰器使用示例",
      "并发函数一般使用",
      "并发函数返回Promise",
      "并发函数中使用自定义类或函数",
      "并发异步函数中使用Promise",
      "TaskPool扩缩容机制",
      "扩容机制",
      "缩容机制"
    ]
  },
  {
    "doc_id": "taskpool-vs-worker",
    "title": "TaskPool和Worker的对比 (TaskPool和Worker)",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\taskpool-vs-worker.md",
    "summary": "TaskPool和Worker的作用是为应用程序提供多线程运行环境，用于处理耗时计算任务或其他密集型任务，避免任务阻塞宿主线程，提高系统性能和资源利用率。 本文将从[实现特点](#实现特点对比)和[适用场景](#适用场景对比)两个方面比较TaskPool与Worker。 **表1** TaskPool和Worker的实现特点对比",
    "key_topics": [
      "TaskPool和Worker的对比 (TaskPool和Worker)",
      "实现特点对比",
      "适用场景对比",
      "建议使用Worker的场景",
      "建议使用TaskPool的场景"
    ],
    "sections": [
      "实现特点对比",
      "适用场景对比",
      "建议使用Worker的场景",
      "建议使用TaskPool的场景"
    ]
  },
  {
    "doc_id": "taskpool-waterflow",
    "title": "ArkUI瀑布流渲染场景",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\taskpool-waterflow.md",
    "summary": "此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。UI线程查询数据库数据，并将数据渲染到瀑布流组件，数据过大时会导致UI线程长时间等待，影响用户体验。因此，我们可以将数据查询操作放到子线程中，并通过TaskPool的接口返回数据给UI线程。",
    "key_topics": [
      "ArkUI瀑布流渲染场景"
    ],
    "sections": []
  },
  {
    "doc_id": "time-consuming-task-overview",
    "title": "耗时任务并发场景简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\time-consuming-task-overview.md",
    "summary": "耗时任务是指需要较长时间执行的任务，如果在UI主线程执行，可能导致应用卡顿、掉帧或响应延迟。典型的耗时任务包括CPU密集型任务、I/O密集型任务和同步任务。 常见的业务场景分类如下： | 常见业务场景 | 具体业务描述 | 是否为CPU密集型任务 | 是否为I/O密集型任务 | 是否为同步任务 | | -------- | -------- | -------- | -------- | -------- | | 图片/视频编解码 | 将图片或视频进行编解码再展示。 | 是 | 是 | 否 | | 压缩/解压缩 | 解压本地压缩包或压缩本地文件。",
    "key_topics": [
      "耗时任务并发场景简介",
      "耗时任务是指需要较长时间执行的任务，如果在UI主线程执行，可能导致应用卡顿、掉帧或响应延迟"
    ],
    "sections": []
  },
  {
    "doc_id": "tool-disassembler",
    "title": "Disassembler反汇编工具",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\tool-disassembler.md",
    "summary": "Disassembler是ArkTS反汇编工具。如果需要分析方舟字节码文件（\\*.abc）相关问题，开发者可以使用Disassembler将方舟字节码文件反编译为可读的汇编指令。 工具随DevEco Studio SDK发布。以Windows平台为例，Disassembler工具位于DevEco Studio/sdk/default/openharmony/toolchains/ark_disasm.exe。 反汇编命令如下：",
    "key_topics": [
      "Disassembler反汇编工具",
      "简介",
      "命令行说明",
      "使用示例",
      "Disassembler是ArkTS反汇编工具"
    ],
    "sections": [
      "简介",
      "命令行说明",
      "使用示例"
    ]
  },
  {
    "doc_id": "transferabled-object",
    "title": "Transferable对象（NativeBinding对象）",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\transferabled-object.md",
    "summary": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，其主要功能由C++提供，JS对象壳则分配在虚拟机的本地堆（LocalHeap）中。跨线程传输时复用同一个C++对象，相比JS对象的拷贝模式，传输效率更高。因此，可共享或转移的NativeBinding对象被称为Transferable对象。开发者可以自定义Transferable对象，详细示例请参考[自定义Native Transferable对象的多线程操作场景](napi-coerce-to-native-binding-object.md)。",
    "key_topics": [
      "Transferable对象（NativeBinding对象）",
      "共享模式",
      "转移模式",
      "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，其主要功能由C++提供，JS对象壳则分配在虚拟机的本地堆（LocalHeap）中"
    ],
    "sections": [
      "共享模式",
      "转移模式"
    ]
  },
  {
    "doc_id": "worker-and-taskpool",
    "title": "Worker常驻线程通过TaskPool进行多任务并发处理",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\worker-and-taskpool.md",
    "summary": "ArkTS应用开发过程中，可以选择TaskPool或Worker线程进行多任务并发处理，也可以两种并发能力都选择。 本示例将说明在Worker线程中通过TaskPool执行并发任务。 1. 在主线程中创建Worker线程并发送消息。",
    "key_topics": [
      "Worker常驻线程通过TaskPool进行多任务并发处理",
      "ArkTS应用开发过程中，可以选择TaskPool或Worker线程进行多任务并发处理，也可以两种并发能力都选择"
    ],
    "sections": []
  },
  {
    "doc_id": "worker-communicates-with-mainthread",
    "title": "Worker和宿主线程的即时消息通信",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\worker-communicates-with-mainthread.md",
    "summary": "在ArkTS中，Worker相对于Taskpool存在一定的差异性，有数量限制但是可以长时间存在。一个[Worker](worker-introduction.md)中可能会执行多个不同的任务，每个任务的执行时长或返回结果可能都不同，宿主线程需要根据情况调用Worker中的不同方法，Worker则需要及时地将结果返回给宿主线程。 下面以Worker响应\"hello world\"请求为例说明。 1. 首先，创建一个执行任务的Worker。创建方法可参考[创建worker的注意事项](worker-introduction.md#创建worker的注意事项)。",
    "key_topics": [
      "Worker和宿主线程的即时消息通信",
      "在ArkTS中，Worker相对于Taskpool存在一定的差异性，有数量限制但是可以长时间存在"
    ],
    "sections": []
  },
  {
    "doc_id": "worker-introduction",
    "title": "Worker简介",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\worker-introduction.md",
    "summary": "Worker的主要作用是为应用程序提供一个多线程的运行环境，实现应用程序执行过程与宿主线程分离。通过在后台线程运行脚本处理耗时操作，避免计算密集型或高延迟任务阻塞宿主线程。具体接口信息及使用方法详情请见[Worker](../reference/apis-arkts/js-apis-worker.md)。 **图1** Worker运作机制示意图 ![worker](figures/worker.png)",
    "key_topics": [
      "Worker简介",
      "Worker运作机制",
      "创建Worker的注意事项",
      "文件路径注意事项",
      "Stage模型下的文件路径规则"
    ],
    "sections": [
      "Worker运作机制",
      "创建Worker的注意事项",
      "文件路径注意事项",
      "Stage模型下的文件路径规则",
      "FA模型下的文件路径规则",
      "生命周期注意事项",
      "其他注意事项",
      "Worker基本用法示例",
      "多级Worker生命周期管理",
      "推荐使用示例",
      "不推荐使用示例"
    ]
  },
  {
    "doc_id": "worker-invoke-mainthread-interface",
    "title": "Worker同步调用宿主线程的接口",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\worker-invoke-mainthread-interface.md",
    "summary": "如果一个接口已在宿主线程中实现，Worker可以通过以下方式调用该接口。 以下示例展示了Worker同步调用宿主线程接口的方法，创建worker的方法可参考[创建worker的注意事项](worker-introduction.md#创建worker的注意事项)。 1. 首先，在宿主线程实现需要调用的接口，并创建Worker对象，在Worker对象上注册需要调用的对象。",
    "key_topics": [
      "Worker同步调用宿主线程的接口",
      "如果一个接口已在宿主线程中实现，Worker可以通过以下方式调用该接口"
    ],
    "sections": []
  },
  {
    "doc_id": "worker-postMessage-sendable",
    "title": "多级Worker间高性能消息通信",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\worker-postMessage-sendable.md",
    "summary": "多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保销毁父Worker前先销毁所有子Worker。 本文介绍如何在多级Worker间实现高性能消息通信。",
    "key_topics": [
      "多级Worker间高性能消息通信"
    ],
    "sections": []
  },
  {
    "doc_id": "xml-conversion",
    "title": "XML转换",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\xml-conversion.md",
    "summary": "将XML文本转换为JavaScript对象，便于处理和操作数据，适用于JavaScript应用程序。 语言基础类库提供ConvertXML类，将XML文本转换为JavaScript对象，输入为待转换的XML字符串及转换选项，输出为转换后的JavaScript对象。具体转换选项可见[API参考@ohos.convertxml](../reference/apis-arkts/js-apis-convertxml.md)。 XML解析及转换需要确保传入的XML数据符合XML标准格式。",
    "key_topics": [
      "XML转换",
      "注意事项",
      "开发步骤",
      "将XML文本转换为JavaScript对象，便于处理和操作数据，适用于JavaScript应用程序"
    ],
    "sections": [
      "注意事项",
      "开发步骤"
    ]
  },
  {
    "doc_id": "xml-generation",
    "title": "XML生成",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\xml-generation.md",
    "summary": "XML可以作为数据交换格式，被各种系统和应用程序支持。例如Web服务，可以将结构化数据以XML格式进行传递。 XML还可以作为消息传递格式，用于分布式系统中不同节点的通信。 - XML标签必须成对出现，生成开始标签就要生成结束标签。",
    "key_topics": [
      "XML生成",
      "注意事项",
      "开发步骤",
      "XML可以作为数据交换格式，被各种系统和应用程序支持"
    ],
    "sections": [
      "注意事项",
      "开发步骤"
    ]
  },
  {
    "doc_id": "xml-overview",
    "title": "XML概述",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\xml-overview.md",
    "summary": "XML（可扩展标记语言）是一种用于描述数据的标记语言，提供通用的数据传输和存储方式。XML不预定义标记，因此更加灵活，适用于广泛的应用领域。 XML文档由元素（element）、属性（attribute）和内容（content）组成。 - 元素指的是标记对，包含文本、属性或其他元素。",
    "key_topics": [
      "XML概述",
      "XML（可扩展标记语言）是一种用于描述数据的标记语言，提供通用的数据传输和存储方式"
    ],
    "sections": []
  },
  {
    "doc_id": "xml-parsing",
    "title": "XML解析",
    "path": "../../docs/zh-cn/application-dev/arkts-utils\\xml-parsing.md",
    "summary": "对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型和元素信息](#解析xml事件类型和元素信息)三类操作。如在Web服务中，XML是SOAP（Simple Object Access Protocol）协议的基础，SOAP消息通常以XML格式封装，包含请求和响应参数，通过解析这些XML消息，Web服务可以处理来自客户端的请求并生成相应的响应。",
    "key_topics": [
      "XML解析",
      "注意事项",
      "解析XML标签和标签值",
      "解析XML属性和属性值",
      "解析XML事件类型和元素信息"
    ],
    "sections": [
      "注意事项",
      "解析XML标签和标签值",
      "解析XML属性和属性值",
      "解析XML事件类型和元素信息",
      "场景示例"
    ]
  }
]