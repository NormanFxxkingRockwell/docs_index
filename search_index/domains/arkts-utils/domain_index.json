{
  "domain": "ArkTS",
  "domain_summary": "ArkTS是OpenHarmony应用开发的官方高级语言，在TypeScript生态基础上做了进一步扩展。ArkTS并发编程提供TaskPool多任务池API，Worker多线程API，以及Sendable对象支持跨线程引用传递。ArkTS基础类库提供XML生成解析转换、Buffer与FastBuffer、容器类库、JSON扩展等能力。ArkTS运行时提供GC垃圾回收、模块化运行、动态加载等能力。ArkTS编译工具链支持语法检查、UI转换、源码混淆、字节码编译、反汇编等功能。",
  "core_concepts": [
    "ASON",
    "ArkTS基础",
    "ArkTS编程语言",
    "ArkTS运行时",
    "ArrayBuffer",
    "Buffer二进制",
    "DataView",
    "GC垃圾回收",
    "JSON扩展",
    "JSON解析",
    "Sendable对象",
    "TaskPool多线程",
    "TypeScript扩展",
    "Worker线程",
    "XML处理",
    "XML生成",
    "XML解析",
    "XML转换",
    "二进制数据",
    "代码混淆",
    "任务优先级",
    "任务队列",
    "保护",
    "内存管理",
    "动态加载",
    "反汇编",
    "后台任务",
    "垃圾回收",
    "多线程环境",
    "字节码格式",
    "字节码混淆",
    "字节码编译",
    "容器类库",
    "并发任务",
    "并发编程",
    "序列化",
    "异步锁",
    "引用传递",
    "懒加载",
    "方舟字节码",
    "条件变量",
    "模块化运行",
    "模块导入",
    "源码混淆",
    "线性容器",
    "线程同步",
    "线程通信",
    "编译工具链",
    "跨线程传递",
    "集合",
    "非线性容器"
  ],
  "document_count": 93,
  "documents": [
    {
      "doc_id": "Readme-CN",
      "title": "ArkTS（方舟编程语言）",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/Readme-CN.md",
      "summary": "- [ArkTS简介](arkts-overview.md) - ArkTS基础类库 - [ArkTS基础类库概述](arkts-utils-overview.md) - XML生成、解析与转换 - [XML概述](xml-overview.md) - [XML生成](xml-generation.md) - [XML解析](xml-parsing.md) - [XML转换](xml-conversion.md) - [Buffer与FastBuffer](buffer.md) - [JSON扩展库](arkts-json.md) - ArkTS容器类库 - [容器类库概述](container-overview.md)",
      "key_topics": [
        "[ArkTS简介](arkts-overview.md)",
        "ArkTS基础类库",
        "[ArkTS基础类库概述](arkts-utils-overview.md)",
        "XML生成、解析与转换",
        "[XML概述](xml-overview.md)"
      ],
      "sections": []
    },
    {
      "doc_id": "arkoptions-guide",
      "title": "在build-profile.json5中配置arkOptions",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkoptions-guide.md",
      "summary": "暂无摘要",
      "key_topics": [
        "概述",
        "types",
        "types配置文件标签说明",
        "arkOptions中的types字段配置说明",
        "注意事项",
        "maxFlowDepth",
        "maxFlowDepth配置文件标签说明",
        "arkOptions下的tscConfig中maxFlowDepth字段配置说明",
        "transformLib",
        "transformLib配置文件标签说明"
      ],
      "sections": [
        "概述",
        "types",
        "types配置文件标签说明",
        "arkOptions中的types字段配置说明",
        "注意事项",
        "maxFlowDepth",
        "maxFlowDepth配置文件标签说明",
        "arkOptions下的tscConfig中maxFlowDepth字段配置说明",
        "transformLib",
        "transformLib配置文件标签说明",
        "arkOptions中的transformLib字段配置说明"
      ]
    },
    {
      "doc_id": "arkts-async-lock-introduction",
      "title": "异步锁",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-async-lock-introduction.md",
      "summary": "为了解决多线程并发实例间的数据竞争问题，ArkTS引入了异步锁能力。异步锁可能会被类对象持有，因此为了更方便地在并发实例间获取同一个异步锁对象，[AsyncLock对象](../reference/apis-arkts/arkts-apis-arkts-utils-locks.md#asynclock)支持跨线程引用传递。",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "arkts-bytecode-file-format",
      "title": "方舟字节码文件格式",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-bytecode-file-format.md",
      "summary": "本文详细介绍了方舟字节码文件的格式，旨在帮助开发者深入理解字节码文件的组成结构，以指导字节码的分析和修改。",
      "key_topics": [
        "约束",
        "字节码文件数据类型",
        "整型",
        "字符串",
        "TaggedValue",
        "TypeDescriptor",
        "字节码文件布局",
        "Header",
        "Version",
        "ForeignClass"
      ],
      "sections": [
        "约束",
        "字节码文件数据类型",
        "整型",
        "字符串",
        "TaggedValue",
        "TypeDescriptor",
        "字节码文件布局",
        "Header",
        "Version",
        "ForeignClass",
        "ForeignMethod",
        "ClassIndex",
        "Class",
        "ClassAccessFlag",
        "ClassTag",
        "Field",
        "FieldTag",
        "Method",
        "MethodIndexData",
        "MethodTag",
        "Code",
        "TryBlock",
        "CatchBlock",
        "Annotation",
        "AnnotationElementTag",
        "AnnotationElement",
        "Value formats",
        "LineNumberProgramIndex",
        "DebugInfo",
        "IndexSection",
        "IndexHeader",
        "ClassRegionIndex",
        "Type",
        "MethodStringLiteralRegionIndex",
        "LiteralArray",
        "Literal"
      ]
    },
    {
      "doc_id": "arkts-bytecode-function-name",
      "title": "方舟字节码函数命名规则",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-bytecode-function-name.md",
      "summary": "暂无摘要",
      "key_topics": [
        "概述",
        "入口函数",
        "非入口函数",
        "前缀",
        "原函数名",
        "示例"
      ],
      "sections": [
        "概述",
        "入口函数",
        "非入口函数",
        "前缀",
        "原函数名",
        "示例"
      ]
    },
    {
      "doc_id": "arkts-bytecode-fundamentals",
      "title": "方舟字节码基本原理",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-bytecode-fundamentals.md",
      "summary": "暂无摘要",
      "key_topics": [
        "总体设计",
        "概述",
        "术语和约束",
        "字节码构成",
        "值存储方式",
        "函数调用规范",
        "字节码格式说明",
        "字节码汇总集合"
      ],
      "sections": [
        "总体设计",
        "概述",
        "术语和约束",
        "字节码构成",
        "值存储方式",
        "函数调用规范",
        "字节码格式说明",
        "字节码汇总集合"
      ]
    },
    {
      "doc_id": "arkts-bytecode-overview",
      "title": "方舟字节码概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-bytecode-overview.md",
      "summary": "方舟字节码文件是ArkTS/TS/JS源码编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。",
      "key_topics": [
        "方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和映射关系。"
      ],
      "sections": []
    },
    {
      "doc_id": "arkts-collections-introduction",
      "title": "共享容器",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-collections-introduction.md",
      "summary": "暂无摘要",
      "key_topics": [
        "ArkTS容器集",
        "共享容器与原生API方法的行为差异对比",
        "Array",
        "ArrayBuffer",
        "TypedArray（以Int8Array为例）",
        "Map",
        "Set"
      ],
      "sections": [
        "ArkTS容器集",
        "共享容器与原生API方法的行为差异对比",
        "Array",
        "ArrayBuffer",
        "TypedArray（以Int8Array为例）",
        "Map",
        "Set"
      ]
    },
    {
      "doc_id": "arkts-condition-variable-introduction",
      "title": "异步等待",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-condition-variable-introduction.md",
      "summary": "ArkTS引入了异步任务的等待和被唤醒能力，以解决多线程任务时序控制问题。异步任务的等待和被唤醒[ConditionVariable](../reference/apis-arkts/arkts-apis-arkts-utils-locks.md#conditionvariable18)对象支持跨线程引用传递。",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "arkts-cross-language-interaction",
      "title": "ArkTS跨语言交互",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-cross-language-interaction.md",
      "summary": "除了支持使用ArkTS开发外，开发者还可以通过Node-API实现ArkTS与C/C++(Native)的跨语言交互能力。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "arkts-dynamic-import",
      "title": "动态加载",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-dynamic-import.md",
      "summary": "动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块之间可通过变量动态import来访问彼此导出的内容，可避免编译期强依赖，实现模块解耦。",
      "key_topics": [
        "技术适用场景介绍",
        "业务扩展场景介绍",
        "动态import实现方案介绍",
        "动态import实现中的关键点",
        "动态import常量表达式",
        "动态import变量表达式",
        "HAR模块间动态import依赖解耦"
      ],
      "sections": [
        "技术适用场景介绍",
        "业务扩展场景介绍",
        "动态import实现方案介绍",
        "动态import实现中的关键点",
        "动态import常量表达式",
        "动态import变量表达式",
        "HAR模块间动态import依赖解耦"
      ]
    },
    {
      "doc_id": "arkts-import-native-module",
      "title": "静态方式加载Native模块",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-import-native-module.md",
      "summary": "在ES6(ECMAScript 6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义的语法规则。为支持开发者使用该功能导入Native模块（so）导出的内容，ArkTS进行了相关适配，并提供了以下几种支持写法。",
      "key_topics": [
        "直接导入",
        "具名导入",
        "默认导入",
        "命名空间导入",
        "间接导入",
        "转为具名变量导出再导入",
        "转为命名空间导出再导入",
        "动态导入"
      ],
      "sections": [
        "直接导入",
        "具名导入",
        "默认导入",
        "命名空间导入",
        "间接导入",
        "转为具名变量导出再导入",
        "转为命名空间导出再导入",
        "动态导入"
      ]
    },
    {
      "doc_id": "arkts-json",
      "title": "JSON扩展库",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-json.md",
      "summary": "暂无摘要",
      "key_topics": [
        "场景介绍",
        "JSON扩展说明",
        "parse",
        "stringify",
        "has",
        "remove",
        "总结",
        "开发场景",
        "解析包含嵌套引号的JSON字符串场景",
        "解析包含大整数的JSON字符串场景"
      ],
      "sections": [
        "场景介绍",
        "JSON扩展说明",
        "parse",
        "stringify",
        "has",
        "remove",
        "总结",
        "开发场景",
        "解析包含嵌套引号的JSON字符串场景",
        "解析包含大整数的JSON字符串场景",
        "序列化BigInt对象场景",
        "序列化浮点数number场景"
      ]
    },
    {
      "doc_id": "arkts-lazy-import",
      "title": "延迟加载（lazy import）",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-lazy-import.md",
      "summary": "随着应用程序功能的扩展，冷启动时间显著增加，主要是因为启动初期加载了大量未实际执行的模块。这不仅延长了应用的初始化时间，还浪费了资源。需要精简加载流程，剔除非必需的文件执行，优化冷启动性能，确保用户体验流畅。",
      "key_topics": [
        "功能特性",
        "使用方式",
        "场景行为解析",
        "lazy-import与动态加载的区别",
        "语法规格及起始支持版本",
        "错误示例",
        "不推荐用法",
        "注意事项",
        "可延迟加载文件检测",
        "检测步骤"
      ],
      "sections": [
        "功能特性",
        "使用方式",
        "场景行为解析",
        "lazy-import与动态加载的区别",
        "语法规格及起始支持版本",
        "错误示例",
        "不推荐用法",
        "注意事项",
        "可延迟加载文件检测",
        "检测步骤",
        "生成文件介绍",
        "检测原理",
        "加载情况总结",
        "被使用文件",
        "未被使用文件",
        "使用示例"
      ]
    },
    {
      "doc_id": "arkts-module-side-effects",
      "title": "模块加载副作用及优化",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-module-side-effects.md",
      "summary": "暂无摘要",
      "key_topics": [
        "概述",
        "ArkTS模块化导致副作用的场景及优化方式",
        "模块执行顶层代码",
        "修改全局对象",
        "修改应用级ArkUI组件的状态变量信息",
        "修改内置全局变量或原型链（ArkTS内禁止修改对象原型与内置方法）",
        "循环依赖",
        "延迟加载（lazy import）改变模块执行顺序，可能导致预期的全局变量未定义",
        "通过import路径展开优化性能",
        "原理"
      ],
      "sections": [
        "概述",
        "ArkTS模块化导致副作用的场景及优化方式",
        "模块执行顶层代码",
        "修改全局对象",
        "修改应用级ArkUI组件的状态变量信息",
        "修改内置全局变量或原型链（ArkTS内禁止修改对象原型与内置方法）",
        "循环依赖",
        "延迟加载（lazy import）改变模块执行顺序，可能导致预期的全局变量未定义",
        "通过import路径展开优化性能",
        "原理",
        "副作用"
      ]
    },
    {
      "doc_id": "arkts-overview",
      "title": "ArkTS简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-overview.md",
      "summary": "ArkTS是OpenHarmony应用开发的官方高级语言。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "arkts-runtime-faq",
      "title": "ArkTS运行时常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-runtime-faq.md",
      "summary": "暂无摘要",
      "key_topics": [
        "正则运算与预期输出结果不一致场景",
        "正则运算对于\\b处理与预期不一致",
        "正则运算对于先行断言((?=pattern)或(?!pattern)) 嵌套在后行断言((?<=pattern)或(?<!pattern))内部的场景与预期不一致",
        "正则运算对于大小写的处理与预期不一致",
        "正则运算/()/ug匹配时lastIndex与预期不一致",
        "正则运算[]内部使用'-'与预期不一致",
        "正则运算具名捕获组获取与预期不一致",
        "正则匹配使用'|'与预期不一致",
        "TypedArray.prototype.map触发内联缓存优化后，在回调中将数值number转为浮点数number与期望不一致",
        "Number.parseFloat解析浮点数number类型非规格化数值与期望不一致"
      ],
      "sections": [
        "正则运算与预期输出结果不一致场景",
        "正则运算对于\\b处理与预期不一致",
        "正则运算对于先行断言((?=pattern)或(?!pattern)) 嵌套在后行断言((?<=pattern)或(?<!pattern))内部的场景与预期不一致",
        "正则运算对于大小写的处理与预期不一致",
        "正则运算/()/ug匹配时lastIndex与预期不一致",
        "正则运算[]内部使用'-'与预期不一致",
        "正则运算具名捕获组获取与预期不一致",
        "正则匹配使用'|'与预期不一致",
        "TypedArray.prototype.map触发内联缓存优化后，在回调中将数值number转为浮点数number与期望不一致",
        "Number.parseFloat解析浮点数number类型非规格化数值与期望不一致",
        "Set constructor入参为多维数组的解析与期望不一致",
        "Object.entries处理Uint8Array与Uint16Array数组结果与期望不一致",
        "字符串 `replace` 接口对于第一个参数为空字符串的场景与预期不一致",
        "Async函数内部异常的处理机制",
        "Array.flatMap()接口常见问题",
        "ArkTS使用场景",
        "ArkUI使用场景",
        "Array.flatMap规避方案",
        "Proxy的handler对象中key类型与EcmaScript规范定义不一致",
        "JSON.stringify的replacer函数中数组索引的key类型与EcmaScript规范定义不一致"
      ]
    },
    {
      "doc_id": "arkts-runtime-overview",
      "title": "ArkTS运行时概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-runtime-overview.md",
      "summary": "ArkTS运行时是OpenHarmony上应用的默认语言运行时，支持ArkTS、TS和JS语言的字节码及相关标准库。它提供解释器、AOT和JIT高效执行方式，并通过[Node-API](../napi/napi-introduction.md)实现完善的跨语言调用接口，支持多语言混合开发。",
      "key_topics": [
        "**Core Subsystem**：主要由与语言无关的基础运行库组成，其中包括承载字节码的File组件、支持Debugger的Tooling组件以及负责适配系统调用的Base库组件等。"
      ],
      "sections": []
    },
    {
      "doc_id": "arkts-sendable-module",
      "title": "共享模块",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-sendable-module.md",
      "summary": "共享模块是进程内只会加载一次的模块，使用\"use shared\"这一指令来标记一个模块是否为共享模块。",
      "key_topics": [
        "约束限制",
        "使用示例"
      ],
      "sections": [
        "约束限制",
        "使用示例"
      ]
    },
    {
      "doc_id": "arkts-sendable",
      "title": "Sendable对象简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-sendable.md",
      "summary": "在传统JS引擎中，要优化对象的并发通信开销，唯一的方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低开销。然而，开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中尚未解决。",
      "key_topics": [
        "基础概念",
        "Sendable协议",
        "ISendable",
        "Sendable class",
        "Sendable function",
        "Sendable interface",
        "Sendable支持的数据类型",
        "Sendable的实现原理",
        "\\@Sendable装饰器"
      ],
      "sections": [
        "基础概念",
        "Sendable协议",
        "ISendable",
        "Sendable class",
        "Sendable function",
        "Sendable interface",
        "Sendable支持的数据类型",
        "Sendable的实现原理",
        "\\@Sendable装饰器"
      ]
    },
    {
      "doc_id": "arkts-utils-overview",
      "title": "ArkTS基础类库概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arkts-utils-overview.md",
      "summary": "ArkTS基础类库是一个功能齐全的API集合，设计了一系列关键且实用的功能模块。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "arraybuffer-object",
      "title": "ArrayBuffer对象",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/arraybuffer-object.md",
      "summary": "ArrayBuffer包含两部分：底层存储数据的Native内存区域，以及封装操作的JS对象壳。JS对象壳分配在虚拟机的本地堆（LocalHeap）中。跨线程传递时，JS对象壳需要序列化和反序列化拷贝传递，而Native内存区域可以通过拷贝或转移的方式传递。",
      "key_topics": [
        "ArrayBuffer拷贝传输方式",
        "ArrayBuffer转移传输方式"
      ],
      "sections": [
        "ArrayBuffer拷贝传输方式",
        "ArrayBuffer转移传输方式"
      ]
    },
    {
      "doc_id": "ason-parsing-generation",
      "title": "ASON解析与生成",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/ason-parsing-generation.md",
      "summary": "[ASON工具](../reference/apis-arkts/arkts-apis-arkts-utils-ASON.md)与JS提供的JSON工具类似，JSON用于进行JS对象的序列化（stringify）、反序列化（parse）。ASON则提供了[Sendable对象](arkts-sendable.md)的序列化、反序列化能力。使用ASON.stringify方法可将对象转换为字符串，使用ASON.parse方法可将字符串转换为Sendable对象，从而实现对象在并发任务间的高性能引用传递。",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "async-concurrency-overview",
      "title": "异步并发 (Promise和async/await)",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/async-concurrency-overview.md",
      "summary": "Promise和async/await是标准的JS异步语法，提供异步并发能力。异步代码执行时会被挂起，稍后继续执行，确保同一时间只有一段代码在运行。以下是典型的异步并发使用场景：",
      "key_topics": [
        "Promise",
        "async/await"
      ],
      "sections": [
        "Promise",
        "async/await"
      ]
    },
    {
      "doc_id": "batch-database-operations-guide",
      "title": "批量数据写数据库场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/batch-database-operations-guide.md",
      "summary": "暂无摘要",
      "key_topics": [
        "使用TaskPool进行频繁数据库操作",
        "使用Sendable进行大容量数据库操作",
        "复杂类实例对象使用Sendable进行大容量数据库操作"
      ],
      "sections": [
        "使用TaskPool进行频繁数据库操作",
        "使用Sendable进行大容量数据库操作",
        "复杂类实例对象使用Sendable进行大容量数据库操作"
      ]
    },
    {
      "doc_id": "buffer",
      "title": "Buffer与FastBuffer",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/buffer.md",
      "summary": "暂无摘要",
      "key_topics": [
        "场景介绍",
        "Buffer",
        "FastBuffer"
      ],
      "sections": [
        "场景介绍",
        "Buffer",
        "FastBuffer"
      ]
    },
    {
      "doc_id": "bytecode-obfuscation-guide",
      "title": "ArkGuard字节码混淆开启指南",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/bytecode-obfuscation-guide.md",
      "summary": "> **注意**： > > 为了避免后续修改代码影响现网问题分析定位，建议开发者在版本发布时，本地备份build/default/cache/default/default@XXXCompileArkTS/esmodule/release/obfuscation 路径下的全部内容； 有条件的可以直接备份release目录。",
      "key_topics": [
        "字节码混淆开启步骤",
        "约束与限制",
        "开启混淆步骤",
        "三种混淆配置文件",
        "混淆选项配置指导",
        "说明",
        "查看混淆效果",
        "报错栈还原"
      ],
      "sections": [
        "字节码混淆开启步骤",
        "约束与限制",
        "开启混淆步骤",
        "三种混淆配置文件",
        "混淆选项配置指导",
        "说明",
        "查看混淆效果",
        "报错栈还原"
      ]
    },
    {
      "doc_id": "bytecode-obfuscation-overview",
      "title": "ArkGuard字节码混淆工具概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/bytecode-obfuscation-overview.md",
      "summary": "从API version 20开始，ArkGuard提供了基础字节码混淆能力，将代码中的函数名、类名、文件名等名字变成简短无意义的名字，提高通过阅读代码猜测其用途的难度。由于混淆后的工程源码中元素名称缩短，有时也可以通过混淆来降低包大小。",
      "key_topics": [
        "[ArkGuard字节码混淆原理及功能](bytecode-obfuscation.md)：说明混淆能力范围（包括默认混淆能力）、混淆流程机制以及各种混淆选项和保留选项的使用方法、混淆规则的合并策略。另外，介绍了ArkGuard在语言环境下的局限性。"
      ],
      "sections": []
    },
    {
      "doc_id": "bytecode-obfuscation-practice",
      "title": "不同包类型的字节码混淆建议",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/bytecode-obfuscation-practice.md",
      "summary": "由于不同包类型的用途及构建流程的差异，开发者对不同包类型使用混淆有不同的注意事项。本文对[HAP](../quick-start/hap-package.md)、[HAR](../quick-start/har-package.md)和[HSP](../quick-start/in-app-hsp.md)三种包类型分别提供建议，帮助开发者高效使用混淆。",
      "key_topics": [
        "推荐混淆选项",
        "HAP包混淆建议",
        "HAR包混淆建议",
        "HAR包通用建议",
        "本地源码HAR包",
        "发布态源码HAR包",
        "发布态字节码HAR包",
        "HSP包混淆建议",
        "HSP包通用建议",
        "本地源码HSP包"
      ],
      "sections": [
        "推荐混淆选项",
        "HAP包混淆建议",
        "HAR包混淆建议",
        "HAR包通用建议",
        "本地源码HAR包",
        "发布态源码HAR包",
        "发布态字节码HAR包",
        "HSP包混淆建议",
        "HSP包通用建议",
        "本地源码HSP包",
        "集成态HSP包"
      ]
    },
    {
      "doc_id": "bytecode-obfuscation-questions",
      "title": "ArkGuard字节码混淆常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/bytecode-obfuscation-questions.md",
      "summary": "暂无摘要",
      "key_topics": [
        "字节码混淆与源码混淆差异",
        "混淆范围差异",
        "混淆选项差异",
        "混淆后文件结构差异",
        "切换注意点",
        "如何排查功能异常",
        "常规配置问题处理",
        "开启enable-bytecode-obfuscation-debugging，没有生成pa文件如何处理",
        "混淆如何查看混淆效果",
        "编译报错处理"
      ],
      "sections": [
        "字节码混淆与源码混淆差异",
        "混淆范围差异",
        "混淆选项差异",
        "混淆后文件结构差异",
        "切换注意点",
        "如何排查功能异常",
        "常规配置问题处理",
        "开启enable-bytecode-obfuscation-debugging，没有生成pa文件如何处理",
        "混淆如何查看混淆效果",
        "编译报错处理",
        "运行异常处理",
        "开启-enable-property-obfuscation选项可能出现的问题",
        "同时开启-enable-export-obfuscation和-enable-toplevel-obfuscation选项可能出现的问题",
        "未开启-enable-string-property-obfuscation混淆选项，字符串字面量属性名却被混淆，导致字符串字面量属性名的值为undefined",
        "开启-enable-filename-obfuscation选项后，可能会出现的问题"
      ]
    },
    {
      "doc_id": "bytecode-obfuscation",
      "title": "ArkGuard字节码混淆原理及功能",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/bytecode-obfuscation.md",
      "summary": "暂无摘要",
      "key_topics": [
        "术语清单",
        "混淆生效范围",
        "适用语言",
        "混淆能力",
        "混淆能力局限性",
        "混淆机制及流程",
        "混淆选项",
        "已有混淆选项汇总",
        "-disable-obfuscation",
        "-enable-property-obfuscation"
      ],
      "sections": [
        "术语清单",
        "混淆生效范围",
        "适用语言",
        "混淆能力",
        "混淆能力局限性",
        "混淆机制及流程",
        "混淆选项",
        "已有混淆选项汇总",
        "-disable-obfuscation",
        "-enable-property-obfuscation",
        "-enable-string-property-obfuscation",
        "-enable-toplevel-obfuscation",
        "-enable-export-obfuscation",
        "-enable-filename-obfuscation",
        "-compact",
        "-remove-log",
        "-print-namecache",
        "-apply-namecache",
        "-enable-lib-obfuscation-options",
        "-enable-bytecode-obfuscation",
        "-enable-bytecode-obfuscation-debugging",
        "保留选项",
        "已有保留选项汇总",
        "-keep-property-name",
        "-keep-global-name",
        "-keep-file-name",
        "-keep-dts",
        "-keep",
        "保留选项支持的通配符",
        "名称类通配符",
        "路径类通配符",
        "混淆规则合并策略",
        "混淆规则合并逻辑"
      ]
    },
    {
      "doc_id": "commonlibrary-faq",
      "title": "基础库常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/commonlibrary-faq.md",
      "summary": "暂无摘要",
      "key_topics": [
        "解析大文件xml发生内存溢出（Out of Memory）"
      ],
      "sections": [
        "解析大文件xml发生内存溢出（Out of Memory）"
      ]
    },
    {
      "doc_id": "compilation-tool-chain-overview",
      "title": "ArkTS编译工具链概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/compilation-tool-chain-overview.md",
      "summary": "ArkTS SDK提供了一套完整的编译工具链，以支持ArkTS的应用编译，通过集成至[Hvigor](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor)编译任务的编排工具上，实现将应用的ArkTS/TS/JS源码编译生成方舟字节码文件（\\*.abc）。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "concurrency-faq",
      "title": "并发常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/concurrency-faq.md",
      "summary": "暂无摘要",
      "key_topics": [
        "TaskPool任务不执行快速定位指导",
        "TaskPool任务执行慢排查思路",
        "排查方向：出问题的TaskPool任务优先级较低，应用后续新增较多优先级更高的TaskPool任务，导致原有低优先级的TaskPool任务执行延后",
        "排查方向：晚执行的TaskPool任务是串行任务或者依赖其他任务",
        "排查方向：@Concurrent标记的方法所在的ets文件里import过多模块",
        "TaskPool序列化失败问题定位指导",
        "Sendable类A的实例对象a传递到子线程后，使用a instanceof A判断返回false",
        "使用Sendable特性抛JS异常排查指导",
        "属性类型不一致异常",
        "新增属性异常"
      ],
      "sections": [
        "TaskPool任务不执行快速定位指导",
        "TaskPool任务执行慢排查思路",
        "排查方向：出问题的TaskPool任务优先级较低，应用后续新增较多优先级更高的TaskPool任务，导致原有低优先级的TaskPool任务执行延后",
        "排查方向：晚执行的TaskPool任务是串行任务或者依赖其他任务",
        "排查方向：@Concurrent标记的方法所在的ets文件里import过多模块",
        "TaskPool序列化失败问题定位指导",
        "Sendable类A的实例对象a传递到子线程后，使用a instanceof A判断返回false",
        "使用Sendable特性抛JS异常排查指导",
        "属性类型不一致异常",
        "新增属性异常",
        "ArkTS提供的Promise能力的原理是什么",
        "TaskPool线程是否可以执行不需要@Concurrent和@Sendable修饰的JS闭包函数",
        "TaskPool任务执行后的结果如何保存到自定义的数据结构",
        "Sendable类在子线程无法加载"
      ]
    },
    {
      "doc_id": "concurrency-overview",
      "title": "并发概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/concurrency-overview.md",
      "summary": "并发指在同一时间内，多个任务同时执行。在多核设备上，任务可以在不同CPU上并行执行。对于单核设备，尽管多个任务不会同时执行，但CPU会在某个任务休眠或进行I/O操作时切换任务，调度其他任务，提高CPU的资源利用率。",
      "key_topics": [
        "异步并发是指异步代码在执行到一定程度后暂停，并在未来某个时间点继续执行，同一时间只有一段代码执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务。详细请参见[使用异步并发能力](async-concurrency-overview.md)。"
      ],
      "sections": []
    },
    {
      "doc_id": "concurrent-loading-modules-guide",
      "title": "业务模块并发加载场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/concurrent-loading-modules-guide.md",
      "summary": "在应用启动时，多个业务模块需要加载，例如地图应用中的定位、打车、导航等模块。如果全部在UI主线程初始化，会严重影响应用冷启动时间。此时，应在不同子线程中并行加载这些模块，以降低启动耗时。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "container-object",
      "title": "容器类对象",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/container-object.md",
      "summary": "容器类对象在跨线程传递时，可通过序列化的形式，确保两个线程的内容一致，从而实现跨线程数据传递。",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "container-overview",
      "title": "容器类库概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/container-overview.md",
      "summary": "容器类库用于存储各种数据类型的元素，提供一系列处理数据的方法，作为纯数据结构容器具有一定的优势。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "cpu-intensive-task-development",
      "title": "CPU密集型任务开发指导 (TaskPool和Worker)",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/cpu-intensive-task-development.md",
      "summary": "CPU密集型任务是指需要占用系统资源进行大量计算的任务，这类任务需要长时间运行，会阻塞线程中其他事件的处理，因此不适合在UI主线程中执行。例如图像处理、视频编码、数据分析等。",
      "key_topics": [
        "使用TaskPool进行图像直方图处理",
        "使用Worker进行长时间数据分析"
      ],
      "sections": [
        "使用TaskPool进行图像直方图处理",
        "使用Worker进行长时间数据分析"
      ]
    },
    {
      "doc_id": "customize-bytecode-during-compilation",
      "title": "编译期自定义修改方舟字节码",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/customize-bytecode-during-compilation.md",
      "summary": "如果开发者希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的方法自定义修改方舟字节码文件。",
      "key_topics": [
        "能力配置说明",
        "能力执行机制",
        "开发示例"
      ],
      "sections": [
        "能力配置说明",
        "能力执行机制",
        "开发示例"
      ]
    },
    {
      "doc_id": "es2abc-faq",
      "title": "方舟字节码生成常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/es2abc-faq.md",
      "summary": "暂无摘要",
      "key_topics": [
        "字节码生成流程",
        "编译时报owns a higher api version错误",
        "编译时报Field {&harname/Index&1.0.0.moduleRecordIdx} has different value错误",
        "编译异常，无具体错误日志"
      ],
      "sections": [
        "字节码生成流程",
        "编译时报owns a higher api version错误",
        "编译时报Field {&harname/Index&1.0.0.moduleRecordIdx} has different value错误",
        "编译异常，无具体错误日志"
      ]
    },
    {
      "doc_id": "gc-introduction",
      "title": "GC垃圾回收",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/gc-introduction.md",
      "summary": "GC（全称 Garbage Collection），即垃圾回收。在计算机领域，GC是指识别并释放内存中的不再使用的对象，以回收内存空间。目前广泛使用的编程语言实现的GC算法主要分为两大类：引用计数和对象追踪（即Tracing GC）。",
      "key_topics": [
        "GC算法简述",
        "GC的类型",
        "对象追踪的三种类型",
        "HPP GC",
        "Heap结构及其配置参数",
        "Heap结构",
        "相关参数",
        "GC流程",
        "HPP GC的类型",
        "触发策略"
      ],
      "sections": [
        "GC算法简述",
        "GC的类型",
        "对象追踪的三种类型",
        "HPP GC",
        "Heap结构及其配置参数",
        "Heap结构",
        "相关参数",
        "GC流程",
        "HPP GC的类型",
        "触发策略",
        "执行策略",
        "SharedHeap",
        "SharedHeap结构",
        "特性",
        "Smart GC",
        "日志解释",
        "开启全量日志",
        "典型日志",
        "GC开发者调试接口",
        "ArkTools.hintGC()",
        "GC常见问题",
        "GC稳定性问题排查指导"
      ]
    },
    {
      "doc_id": "global-configuration-guide",
      "title": "全局配置项功能场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/global-configuration-guide.md",
      "summary": "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项功能，可以采用[共享模块](arkts-sendable-module.md)来实现。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "independent-time-consuming-task",
      "title": "使用TaskPool执行独立的耗时任务",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/independent-time-consuming-task.md",
      "summary": "对于独立运行的耗时任务，任务完成后将结果返回给宿主线程。可采用以下方式实现。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "interthread-communication-overview",
      "title": "ArkTS线程间通信概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/interthread-communication-overview.md",
      "summary": "线程间通信指并发多线程间的数据交换行为。由于ArkTS语言兼容TS/JS，其运行时实现与其它JS引擎一样，采用基于Actor内存隔离的并发模型。",
      "key_topics": [
        "Worker是Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。"
      ],
      "sections": []
    },
    {
      "doc_id": "io-intensive-task-development",
      "title": "I/O密集型任务开发指导 (TaskPool)",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/io-intensive-task-development.md",
      "summary": "使用异步并发可以解决单次I/O任务阻塞的问题。对于I/O密集型任务，若线程中的其他任务仍可能被阻塞，建议采用多线程并发来处理。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "js-apis-load-native-module",
      "title": "同步方式动态加载Native模块",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/js-apis-load-native-module.md",
      "summary": "[loadNativeModule接口](../reference/common/js-apis-common-load-native-module.md)用于同步动态加载Native模块，目的是按需加载所需要的模块。使用该接口会增加加载so文件的时间，开发者需评估其对功能的影响。",
      "key_topics": [
        "函数说明",
        "loadNativeModule支持的场景",
        "使用示例"
      ],
      "sections": [
        "函数说明",
        "loadNativeModule支持的场景",
        "使用示例"
      ]
    },
    {
      "doc_id": "linear-container",
      "title": "线性容器",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/linear-container.md",
      "summary": "线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。",
      "key_topics": [
        "各线性容器类型特征对比",
        "ArrayList",
        "List",
        "LinkedList",
        "Deque",
        "Queue",
        "Stack",
        "Vector",
        "线性容器的使用"
      ],
      "sections": [
        "各线性容器类型特征对比",
        "ArrayList",
        "List",
        "LinkedList",
        "Deque",
        "Queue",
        "Stack",
        "Vector",
        "线性容器的使用"
      ]
    },
    {
      "doc_id": "load-module-base-nodeapi",
      "title": "基于Node-API加载模块",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/load-module-base-nodeapi.md",
      "summary": "Node-API中有多种方式支持开发者在C++侧加载工程内模块及文件。推荐使用napi_load_module_with_info接口。",
      "key_topics": [
        "napi_load_module_with_info",
        "napi_load_module"
      ],
      "sections": [
        "napi_load_module_with_info",
        "napi_load_module"
      ]
    },
    {
      "doc_id": "long-time-task-guide",
      "title": "长时任务开发指导（TaskPool）",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/long-time-task-guide.md",
      "summary": "此处提供使用TaskPool进行长时任务的开发指导，以定期采集传感器数据为例。",
      "key_topics": [
        "使用TaskPool进行传感器数据监听"
      ],
      "sections": [
        "使用TaskPool进行传感器数据监听"
      ]
    },
    {
      "doc_id": "long-time-task-overview",
      "title": "长时任务并发场景简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/long-time-task-overview.md",
      "summary": "在应用业务实现过程中，需要较长时间不定时运行的任务称为长时任务。如果在UI主线程中执行这些长时任务，会阻塞UI业务，导致卡顿和丢帧等问题，影响用户体验。因此，通常需要将这些独立的长时任务放到单独的子线程中执行。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "makeobserved-sendable",
      "title": "ArkUI数据更新场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/makeobserved-sendable.md",
      "summary": "当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。",
      "key_topics": [
        "makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI更新。",
        "从子线程获取数据，整体替换UI线程的可观察数据。",
        "从子线程获取的数据重新执行makeObserved，变为可观察数据。",
        "将数据从UI主线程传递回子线程时，只传递不可观察的数据。makeObserved的返回值不能直接传给子线程。"
      ],
      "sections": []
    },
    {
      "doc_id": "module-principle",
      "title": "模块化运行简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/module-principle.md",
      "summary": "为了解决大型或复杂应用开发过程中，部分代码编译时被多次拷贝导致包体积增大、文件依赖、代码与资源共享困难以及单例和全局变量污染等问题，ArkTS支持应用模块化编译、打包和运行，简化代码的编写与维护。",
      "key_topics": [
        "模块化运行加载流程",
        "ArkTS支持的模块化规范",
        "ECMAScript模块",
        "CommonJS模块",
        "CommonJS与ES Module支持规格",
        "ArkTS支持加载的模块类型",
        "ets/ts/js",
        "JSON文件",
        "Native模块"
      ],
      "sections": [
        "模块化运行加载流程",
        "ArkTS支持的模块化规范",
        "ECMAScript模块",
        "CommonJS模块",
        "CommonJS与ES Module支持规格",
        "ArkTS支持加载的模块类型",
        "ets/ts/js",
        "JSON文件",
        "Native模块"
      ]
    },
    {
      "doc_id": "multi-thread-cancel-task",
      "title": "多线程取消TaskPool任务场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/multi-thread-cancel-task.md",
      "summary": "由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，无法在子线程中直接取消任务。从 API version 18 开始，Task新增了[任务ID](../reference/apis-arkts/js-apis-taskpool.md#属性)属性，支持通过任务ID在子线程中取消任务。开发者可将已创建任务的任务ID存储在[Sendable对象](./arkts-sendable.md)中，需要取消任务时，通过Sendable对象在子线程中取消任务。详情可参考以下示例。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "multi-thread-concurrency-overview",
      "title": "多线程并发概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/multi-thread-concurrency-overview.md",
      "summary": "多线程并发是指在单个程序中同时运行多个线程，通过并行或交替执行任务来提升性能和资源利用率的编程模型。在ArkTS应用开发中，多线程并发适用于多种业务场景，常见的业务场景主要分为以下三类，更详细的使用请参考[多线程开发实践案例](batch-database-operations-guide.md)。",
      "key_topics": [
        "多线程并发模型",
        "内存共享模型",
        "Actor模型",
        "TaskPool和Worker",
        "并发注意事项"
      ],
      "sections": [
        "多线程并发模型",
        "内存共享模型",
        "Actor模型",
        "TaskPool和Worker",
        "并发注意事项"
      ]
    },
    {
      "doc_id": "multi-time-consuming-tasks",
      "title": "使用TaskPool执行多个耗时任务",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/multi-time-consuming-tasks.md",
      "summary": "多个任务同时执行时，由于任务复杂度不同，执行时间和返回数据的时间也会不同。如果宿主线程需要所有任务执行完毕的数据，可以通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "multithread-develop-overview",
      "title": "应用多线程开发概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/multithread-develop-overview.md",
      "summary": "在ArkTS应用开发中，不同业务场景需要不同的并发能力和任务类型。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "napi-coerce-to-native-binding-object",
      "title": "自定义Native Transferable对象的多线程操作场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/napi-coerce-to-native-binding-object.md",
      "summary": "在ArkTS应用开发中，有很多场景需要将ArkTS对象与Native对象进行绑定。ArkTS对象将数据写入Native对象，Native对象再将数据写入目的地。例如，将ArkTS对象中的数据写入C++数据库场景。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "napi-define-sendable-object",
      "title": "自定义Native Sendable对象的多线程操作场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/napi-define-sendable-object.md",
      "summary": "ArkTS支持开发者自定义Native Sendable对象，Sendable对象提供了并发实例间高效的通信能力，即引用传递，适用于开发者自定义大对象需要线程间通信的场景，例如子线程读取数据库数据并返回给宿主线程。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "native-interthread-shared",
      "title": "C++线程间数据共享场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/native-interthread-shared.md",
      "summary": "在C++层进行多线程并发计算时，需要在每个C++线程上创建ArkTS执行环境，直接调用API。这样可以避免在非UI主线程回调时等待UI主线程的API调用结果。同时，还需要在C++线程之间共享和操作Sendable对象。",
      "key_topics": [
        "在C++线程上调用ArkTS能力",
        "在C++线程之间操作Sendable共享对象"
      ],
      "sections": [
        "在C++线程上调用ArkTS能力",
        "在C++线程之间操作Sendable共享对象"
      ]
    },
    {
      "doc_id": "nonlinear-container",
      "title": "非线性容器",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/nonlinear-container.md",
      "summary": "非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。",
      "key_topics": [
        "各非线性容器类型特征对比",
        "HashMap",
        "HashSet",
        "TreeMap",
        "TreeSet",
        "LightWeightMap",
        "LightWeightSet",
        "PlainArray",
        "非线性容器的使用"
      ],
      "sections": [
        "各非线性容器类型特征对比",
        "HashMap",
        "HashSet",
        "TreeMap",
        "TreeSet",
        "LightWeightMap",
        "LightWeightSet",
        "PlainArray",
        "非线性容器的使用"
      ]
    },
    {
      "doc_id": "normal-object",
      "title": "普通对象",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/normal-object.md",
      "summary": "普通对象跨线程时通过拷贝（序列化）形式传递，两个线程的对象内容一致，但指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）。序列化支持类型包括：除Symbol之外的基础类型、Date、String、RegExp、Array、Map、Set、Object（仅限简单对象，比如通过\"{}\"或者\"new Object\"创建，普通对象仅支持传递属性，不支持传递其原型及方法）、ArrayBuffer、TypedArray。通信过程如图所示：",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "resident-task-guide",
      "title": "常驻任务开发指导（Worker）",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/resident-task-guide.md",
      "summary": "提供使用Worker进行常驻任务的开发指导。Worker将持续执行任务，直到宿主线程发送终止指令。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "resident-task-overview",
      "title": "常驻任务并发场景简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/resident-task-overview.md",
      "summary": "在应用业务实现中，对于耗时较长（超过3分钟）且并发量较小的常驻任务，建议使用Worker在后台线程中执行这些操作，以避免阻塞UI主线程，防止出现丢帧、卡顿等影响用户体验的问题。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "sendable-constraints",
      "title": "Sendable使用规则与约束",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/sendable-constraints.md",
      "summary": "暂无摘要",
      "key_topics": [
        "继承规则",
        "Sendable类必须继承自Sendable类",
        "非Sendable类必须继承自非Sendable类",
        "接口实现规则",
        "非Sendable类禁止实现Sendable接口",
        "Sendable类/接口成员变量规则",
        "必须是Sendable支持的数据类型",
        "不支持使用!断言",
        "不支持使用计算属性名",
        "不支持使用类型别名"
      ],
      "sections": [
        "继承规则",
        "Sendable类必须继承自Sendable类",
        "非Sendable类必须继承自非Sendable类",
        "接口实现规则",
        "非Sendable类禁止实现Sendable接口",
        "Sendable类/接口成员变量规则",
        "必须是Sendable支持的数据类型",
        "不支持使用!断言",
        "不支持使用计算属性名",
        "不支持使用类型别名",
        "泛型规则",
        "泛型类中的Sendable类、SendableLruCache、collections.Array、collections.Map和collections.Set的模板类型必须是Sendable类型",
        "上下文访问规则",
        "Sendable类的内部不允许使用当前模块内上下文环境中定义的变量",
        "\\@Sendable装饰器使用规则",
        "\\@Sendable装饰器仅支持修饰类和函数",
        "Sendable类和Sendable函数禁止使用除\\@Sendable外的装饰器",
        "支持在Sendable class上叠加自定义装饰器",
        "初始化规则",
        "禁止使用对象字面量/数组字面量初始化Sendable对象",
        "类型转换规则",
        "禁止非Sendable类型强制转换为Sendable",
        "函数规则",
        "箭头函数不可标记为Sendable",
        "与TS/JS交互的规则",
        "ArkTS通用规则（目前只针对Sendable对象）",
        "NAPI规则（目前只针对Sendable对象）",
        "与UI交互的规则",
        "在HAR包中的使用规则"
      ]
    },
    {
      "doc_id": "sendable-freeze",
      "title": "Sendable对象冻结",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/sendable-freeze.md",
      "summary": "Sendable对象支持冻结操作。冻结后，对象变为只读，不能修改属性。因此，多个并发实例间访问时无需加锁。可以通过调用[Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)接口冻结对象。",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "sendable-guide",
      "title": "Sendable使用场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/sendable-guide.md",
      "summary": "Sendable对象在不同并发实例间默认采用引用传递，这种方式比序列化更高效，且不会丢失类成员方法。因此，Sendable能够解决两个关键场景的问题：",
      "key_topics": [
        "跨并发实例传输大数据场景",
        "跨并发实例传递带方法的class实例对象"
      ],
      "sections": [
        "跨并发实例传输大数据场景",
        "跨并发实例传递带方法的class实例对象"
      ]
    },
    {
      "doc_id": "sendablelrucache-recent-list",
      "title": "获取最近访问列表场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/sendablelrucache-recent-list.md",
      "summary": "为了快速访问最近使用的[Sendable](arkts-sendable.md)对象，从API version 18开始，ArkTS引入了[SendableLruCache](../reference/apis-arkts/arkts-apis-arkts-utils-SendableLruCache.md)。开发者可以通过向SendableLruCache实例中添加、删除和获取Sendable对象，实现快速访问最近使用的Sendable对象。本文提供使用SendableLruCache实现获取最近使用列表的开发指导，以书架为例，每次打开一本图书后，需将图书信息更新到最近访问列表中，并在下次访问书架页面时显示最近访问的图书列表。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "serializable-overview",
      "title": "线程间通信对象概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/serializable-overview.md",
      "summary": "在多线程并发场景中，例如通过TaskPool或Worker创建后台线程，不同线程间需要进行数据交互。由于线程间内存隔离，线程间通信对象必须通过序列化实现值拷贝或内存共享。",
      "key_topics": [
        "[普通对象](normal-object.md)：可直接传递基本数据类型及自定义对象（需满足序列化规范）。",
        "[容器类对象](container-object.md)：可直接传递已经支持的容器类对象（需满足序列化规范）。",
        "[ArrayBuffer对象](arraybuffer-object.md)：用于二进制数据的高效传递，适用于大段连续内存数据（如图片、音频原始数据）。",
        "[SharedArrayBuffer对象](shared-arraybuffer-object.md)：支持多线程共享内存，允许线程间直接访问同一块内存区域，提升数据传递效率。",
        "[Transferable对象（NativeBinding对象）](transferabled-object.md)：支持跨线程转移对象所有权（如文件描述符、图形资源等），转移后原线程不再拥有访问权限。"
      ],
      "sections": []
    },
    {
      "doc_id": "shared-arraybuffer-object",
      "title": "SharedArrayBuffer对象",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/shared-arraybuffer-object.md",
      "summary": "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可用于多个并发实例间的状态或数据共享。通信过程如下图所示：",
      "key_topics": [
        "使用示例"
      ],
      "sections": [
        "使用示例"
      ]
    },
    {
      "doc_id": "source-obfuscation-guide",
      "title": "ArkGuard混淆开启指南",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/source-obfuscation-guide.md",
      "summary": "暂无摘要",
      "key_topics": [
        "开启源码混淆",
        "开启混淆步骤",
        "三种混淆配置文件",
        "混淆选项配置指导",
        "说明",
        "查看混淆效果",
        "报错栈还原"
      ],
      "sections": [
        "开启源码混淆",
        "开启混淆步骤",
        "三种混淆配置文件",
        "混淆选项配置指导",
        "说明",
        "查看混淆效果",
        "报错栈还原"
      ]
    },
    {
      "doc_id": "source-obfuscation-overview",
      "title": "ArkGuard源码混淆工具概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/source-obfuscation-overview.md",
      "summary": "ArkGuard是一款源码混淆工具，提供基础混淆功能。它将代码中的变量名、函数名、类名、文件名等替换为简短无意义的标识符，增加通过阅读代码推测其功能的难度。混淆后，工程源码中的元素名称简化，有助于减小程序包的体积。",
      "key_topics": [
        "[ArkGuard混淆原理及功能](source-obfuscation.md)：说明混淆能力范围、混淆流程机制、混淆选项和保留选项的使用方法、以及混淆规则的合并策略，以及混淆各功能起始API版本。"
      ],
      "sections": []
    },
    {
      "doc_id": "source-obfuscation-practice",
      "title": "不同包类型的源码混淆建议",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/source-obfuscation-practice.md",
      "summary": "不同包类型的用途和构建流程存在差异，对不同包类型使用混淆时，开发者需要注意不同事项。本文针对[HAP](../quick-start/hap-package.md)、[HAR](../quick-start/har-package.md)和[HSP](../quick-start/in-app-hsp.md)三种包类型，分别提供混淆建议，帮助开发者高效使用混淆。",
      "key_topics": [
        "推荐混淆功能",
        "HAP包混淆建议",
        "HAR包混淆建议",
        "HAR包通用建议",
        "本地源码HAR包",
        "发布态源码HAR包",
        "发布态字节码HAR包",
        "HSP包源码混淆",
        "HSP包通用建议",
        "本地源码HSP包"
      ],
      "sections": [
        "推荐混淆功能",
        "HAP包混淆建议",
        "HAR包混淆建议",
        "HAR包通用建议",
        "本地源码HAR包",
        "发布态源码HAR包",
        "发布态字节码HAR包",
        "HSP包源码混淆",
        "HSP包通用建议",
        "本地源码HSP包",
        "集成态HSP包"
      ]
    },
    {
      "doc_id": "source-obfuscation-questions",
      "title": "ArkGuard混淆常见问题",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/source-obfuscation-questions.md",
      "summary": "暂无摘要",
      "key_topics": [
        "如何排查功能异常",
        "排查功能异常步骤",
        "排查非预期的混淆能力",
        "典型报错案例及解决方案",
        "报错信息为：Error message: Cannot read property xxx of undefined",
        "报错信息为：Error message: is not callable",
        "报错信息为：'module1/file1' does not provide an export name 'x', which is imported by 'module2/file2'",
        "应用运行后无crash信息，但功能异常的情况",
        "使用Record<string, Object>作为对象的类型定义时，属性被混淆",
        "跨文件调用某属性，该属性在一个文件中保留，在另一个文件中被混淆"
      ],
      "sections": [
        "如何排查功能异常",
        "排查功能异常步骤",
        "排查非预期的混淆能力",
        "典型报错案例及解决方案",
        "报错信息为：Error message: Cannot read property xxx of undefined",
        "报错信息为：Error message: is not callable",
        "报错信息为：'module1/file1' does not provide an export name 'x', which is imported by 'module2/file2'",
        "应用运行后无crash信息，但功能异常的情况",
        "使用Record<string, Object>作为对象的类型定义时，属性被混淆",
        "跨文件调用某属性，该属性在一个文件中保留，在另一个文件中被混淆",
        "未开启-enable-string-property-obfuscation，字符串字面量属性名却被混淆",
        "数据库相关的字段被混淆后导致功能异常"
      ]
    },
    {
      "doc_id": "source-obfuscation",
      "title": "ArkGuard混淆原理及功能",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/source-obfuscation.md",
      "summary": "暂无摘要",
      "key_topics": [
        "术语清单",
        "混淆能力范围",
        "适用语言",
        "混淆能力",
        "混淆能力局限性",
        "混淆机制及流程",
        "混淆选项",
        "已有混淆选项汇总",
        "默认混淆",
        "-disable-obfuscation"
      ],
      "sections": [
        "术语清单",
        "混淆能力范围",
        "适用语言",
        "混淆能力",
        "混淆能力局限性",
        "混淆机制及流程",
        "混淆选项",
        "已有混淆选项汇总",
        "默认混淆",
        "-disable-obfuscation",
        "-enable-property-obfuscation",
        "-enable-string-property-obfuscation",
        "-enable-toplevel-obfuscation",
        "-enable-export-obfuscation",
        "-enable-filename-obfuscation",
        "-compact",
        "-remove-comments",
        "-remove-log",
        "-print-namecache",
        "-apply-namecache",
        "-print-kept-names",
        "-extra-options strip-language-default",
        "-extra-options strip-system-api-args",
        "-extra-options strip-not-compiled-module-name",
        "-keep-parameter-names",
        "-enable-lib-obfuscation-options",
        "-use-keep-in-source",
        "-keep-object-props",
        "-remove-nosideeffects-calls",
        "保留选项",
        "已有保留选项汇总",
        "-keep-property-name",
        "-keep-global-name",
        "-keep-file-name",
        "-keep-comments",
        "-keep-dts",
        "-keep",
        "保留选项支持的通配符",
        "混淆规则合并策略",
        "混淆各功能起始API版本"
      ]
    },
    {
      "doc_id": "sync-task-development",
      "title": "同步任务开发指导 (TaskPool和Worker)",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/sync-task-development.md",
      "summary": "同步任务用于在多个线程间协调执行，确保任务按特定顺序和规则进行（如使用锁防止数据竞争）。",
      "key_topics": [
        "使用TaskPool处理同步任务",
        "使用Worker处理关联的同步任务"
      ],
      "sections": [
        "使用TaskPool处理同步任务",
        "使用Worker处理关联的同步任务"
      ]
    },
    {
      "doc_id": "taskpool-async-task-guide",
      "title": "TaskPool指定任务并发度场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/taskpool-async-task-guide.md",
      "summary": "TaskPool支持使用异步队列来控制任务的并发度，能有效避免资源过载，减少任务阻塞，适用于网络请求、视频流处理和数据库操作等场景。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "taskpool-communicates-with-mainthread",
      "title": "TaskPool任务与宿主线程通信",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/taskpool-communicates-with-mainthread.md",
      "summary": "如果Task不仅需要返回最终执行结果，还需定时通知宿主线程状态和数据变化，或分段返回大量数据（如从数据库读取大量数据），可按以下方式实现。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "taskpool-introduction",
      "title": "TaskPool简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/taskpool-introduction.md",
      "summary": "TaskPool为应用程序提供多线程环境，降低资源消耗并提高系统性能。无需管理线程生命周期。具体接口信息及使用方法，请参见[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)。",
      "key_topics": [
        "TaskPool运作机制",
        "TaskPool注意事项",
        "\\@Concurrent装饰器",
        "装饰器使用示例",
        "并发函数一般使用",
        "并发函数返回Promise",
        "并发函数中使用自定义类或函数",
        "并发异步函数中使用Promise",
        "TaskPool扩缩容机制",
        "扩容机制"
      ],
      "sections": [
        "TaskPool运作机制",
        "TaskPool注意事项",
        "\\@Concurrent装饰器",
        "装饰器使用示例",
        "并发函数一般使用",
        "并发函数返回Promise",
        "并发函数中使用自定义类或函数",
        "并发异步函数中使用Promise",
        "TaskPool扩缩容机制",
        "扩容机制",
        "缩容机制"
      ]
    },
    {
      "doc_id": "taskpool-vs-worker",
      "title": "TaskPool和Worker的对比 (TaskPool和Worker)",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/taskpool-vs-worker.md",
      "summary": "TaskPool和Worker的作用是为应用程序提供多线程运行环境，用于处理耗时计算任务或其他密集型任务，避免任务阻塞宿主线程，提高系统性能和资源利用率。",
      "key_topics": [
        "实现特点对比",
        "适用场景对比",
        "建议使用Worker的场景",
        "建议使用TaskPool的场景"
      ],
      "sections": [
        "实现特点对比",
        "适用场景对比",
        "建议使用Worker的场景",
        "建议使用TaskPool的场景"
      ]
    },
    {
      "doc_id": "taskpool-waterflow",
      "title": "ArkUI瀑布流渲染场景",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/taskpool-waterflow.md",
      "summary": "此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。UI线程查询数据库数据，并将数据渲染到瀑布流组件，数据过大时会导致UI线程长时间等待，影响用户体验。因此，我们可以将数据查询操作放到子线程中，并通过TaskPool的接口返回数据给UI线程。",
      "key_topics": [
        "模拟子线程[读取数据库数据](batch-database-operations-guide.md)并返回给UI线程。",
        "UI线程感知到数据更新，将子线程返回的数据渲染到瀑布流组件。"
      ],
      "sections": []
    },
    {
      "doc_id": "time-consuming-task-overview",
      "title": "耗时任务并发场景简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/time-consuming-task-overview.md",
      "summary": "耗时任务是指需要较长时间执行的任务，如果在UI主线程执行，可能导致应用卡顿、掉帧或响应延迟。典型的耗时任务包括CPU密集型任务、I/O密集型任务和同步任务。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "tool-disassembler",
      "title": "Disassembler反汇编工具",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/tool-disassembler.md",
      "summary": "暂无摘要",
      "key_topics": [
        "简介",
        "命令行说明",
        "使用示例"
      ],
      "sections": [
        "简介",
        "命令行说明",
        "使用示例"
      ]
    },
    {
      "doc_id": "transferabled-object",
      "title": "Transferable对象（NativeBinding对象）",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/transferabled-object.md",
      "summary": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，其主要功能由C++提供，JS对象壳则分配在虚拟机的本地堆（LocalHeap）中。跨线程传输时复用同一个C++对象，相比JS对象的拷贝模式，传输效率更高。因此，可共享或转移的NativeBinding对象被称为Transferable对象。开发者可以自定义Transferable对象，详细示例请参考[自定义Native Transferable对象的多线程操作场景](napi-coerce-to-native-binding-object.md)。",
      "key_topics": [
        "共享模式",
        "转移模式"
      ],
      "sections": [
        "共享模式",
        "转移模式"
      ]
    },
    {
      "doc_id": "worker-and-taskpool",
      "title": "Worker常驻线程通过TaskPool进行多任务并发处理",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/worker-and-taskpool.md",
      "summary": "ArkTS应用开发过程中，可以选择TaskPool或Worker线程进行多任务并发处理，也可以两种并发能力都选择。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "worker-communicates-with-mainthread",
      "title": "Worker和宿主线程的即时消息通信",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/worker-communicates-with-mainthread.md",
      "summary": "在ArkTS中，Worker相对于Taskpool存在一定的差异性，有数量限制但是可以长时间存在。一个[Worker](worker-introduction.md)中可能会执行多个不同的任务，每个任务的执行时长或返回结果可能都不同，宿主线程需要根据情况调用Worker中的不同方法，Worker则需要及时地将结果返回给宿主线程。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "worker-introduction",
      "title": "Worker简介",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/worker-introduction.md",
      "summary": "Worker的主要作用是为应用程序提供一个多线程的运行环境，实现应用程序执行过程与宿主线程分离。通过在后台线程运行脚本处理耗时操作，避免计算密集型或高延迟任务阻塞宿主线程。具体接口信息及使用方法详情请见[Worker](../reference/apis-arkts/js-apis-worker.md)。",
      "key_topics": [
        "Worker运作机制",
        "创建Worker的注意事项",
        "文件路径注意事项",
        "Stage模型下的文件路径规则",
        "FA模型下的文件路径规则",
        "生命周期注意事项",
        "其他注意事项",
        "Worker基本用法示例",
        "多级Worker生命周期管理",
        "推荐使用示例"
      ],
      "sections": [
        "Worker运作机制",
        "创建Worker的注意事项",
        "文件路径注意事项",
        "Stage模型下的文件路径规则",
        "FA模型下的文件路径规则",
        "生命周期注意事项",
        "其他注意事项",
        "Worker基本用法示例",
        "多级Worker生命周期管理",
        "推荐使用示例",
        "不推荐使用示例"
      ]
    },
    {
      "doc_id": "worker-invoke-mainthread-interface",
      "title": "Worker同步调用宿主线程的接口",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/worker-invoke-mainthread-interface.md",
      "summary": "如果一个接口已在宿主线程中实现，Worker可以通过以下方式调用该接口。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "worker-postMessage-sendable",
      "title": "多级Worker间高性能消息通信",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/worker-postMessage-sendable.md",
      "summary": "多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保销毁父Worker前先销毁所有子Worker。",
      "key_topics": [],
      "sections": []
    },
    {
      "doc_id": "xml-conversion",
      "title": "XML转换",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/xml-conversion.md",
      "summary": "将XML文本转换为JavaScript对象，便于处理和操作数据，适用于JavaScript应用程序。",
      "key_topics": [
        "注意事项",
        "开发步骤"
      ],
      "sections": [
        "注意事项",
        "开发步骤"
      ]
    },
    {
      "doc_id": "xml-generation",
      "title": "XML生成",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/xml-generation.md",
      "summary": "XML可以作为数据交换格式，被各种系统和应用程序支持。例如Web服务，可以将结构化数据以XML格式进行传递。",
      "key_topics": [
        "注意事项",
        "开发步骤"
      ],
      "sections": [
        "注意事项",
        "开发步骤"
      ]
    },
    {
      "doc_id": "xml-overview",
      "title": "XML概述",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/xml-overview.md",
      "summary": "XML（可扩展标记语言）是一种用于描述数据的标记语言，提供通用的数据传输和存储方式。XML不预定义标记，因此更加灵活，适用于广泛的应用领域。",
      "key_topics": [
        "元素指的是标记对，包含文本、属性或其他元素。"
      ],
      "sections": []
    },
    {
      "doc_id": "xml-parsing",
      "title": "XML解析",
      "path": "../../docs/zh-cn/application-dev/arkts-utils/xml-parsing.md",
      "summary": "对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型和元素信息](#解析xml事件类型和元素信息)三类操作。如在Web服务中，XML是SOAP（Simple Object Access Protocol）协议的基础，SOAP消息通常以XML格式封装，包含请求和响应参数，通过解析这些XML消息，Web服务可以处理来自客户端的请求并生成相应的响应。",
      "key_topics": [
        "注意事项",
        "解析XML标签和标签值",
        "解析XML属性和属性值",
        "解析XML事件类型和元素信息",
        "场景示例"
      ],
      "sections": [
        "注意事项",
        "解析XML标签和标签值",
        "解析XML属性和属性值",
        "解析XML事件类型和元素信息",
        "场景示例"
      ]
    }
  ]
}